; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\modbus.crf ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;786    //-----------------------------CRC检测--------------------------------------------//
;;;787    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b530              PUSH     {r4,r5,lr}
;;;788    {
000002  4603              MOV      r3,r0
;;;789    	vu16 CRC_Result=0xffff;
000004  f64f70ff          MOV      r0,#0xffff
;;;790    	vu8 i;
;;;791    	if(count==0)
000008  b901              CBNZ     r1,|L1.12|
;;;792    	{
;;;793    		count=1;
00000a  2101              MOVS     r1,#1
                  |L1.12|
;;;794    	}
;;;795    	while(count--)
;;;796    	{
;;;797    		CRC_Result^=*p_buffer;
;;;798    		for(i=0;i<8;i++)
;;;799    		{
;;;800    			if(CRC_Result&1)
;;;801    			{
;;;802    				CRC_Result>>=1;
;;;803    				CRC_Result^=0xA001;
00000c  f24a0401          MOV      r4,#0xa001
;;;804    			}
;;;805    			else 
;;;806    			{
;;;807    				CRC_Result>>=1;
;;;808    			}
;;;809    		}
;;;810    		p_buffer++;
000010  e00e              B        |L1.48|
                  |L1.18|
000012  781a              LDRB     r2,[r3,#0]            ;797
000014  4050              EORS     r0,r0,r2              ;797
000016  2200              MOVS     r2,#0                 ;798
000018  e007              B        |L1.42|
                  |L1.26|
00001a  07c5              LSLS     r5,r0,#31             ;800
00001c  d002              BEQ      |L1.36|
00001e  0840              LSRS     r0,r0,#1              ;802
000020  4060              EORS     r0,r0,r4              ;803
000022  e000              B        |L1.38|
                  |L1.36|
000024  0840              LSRS     r0,r0,#1              ;807
                  |L1.38|
000026  1c52              ADDS     r2,r2,#1              ;798
000028  b2d2              UXTB     r2,r2                 ;798
                  |L1.42|
00002a  2a08              CMP      r2,#8                 ;798
00002c  d3f5              BCC      |L1.26|
00002e  1c5b              ADDS     r3,r3,#1
                  |L1.48|
000030  000a              MOVS     r2,r1                 ;795
000032  f1a10101          SUB      r1,r1,#1              ;795
000036  b2c9              UXTB     r1,r1                 ;795
000038  d1eb              BNE      |L1.18|
;;;811    	}
;;;812    	return CRC_Result;
;;;813    }
00003a  bd30              POP      {r4,r5,pc}
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;585    //===============================AD值转换成测量值============================================//
;;;586    void Transformation_ADC(void)  
000000  b5f0              PUSH     {r4-r7,lr}
;;;587    {
;;;588    	vu32 var32;
;;;589    	vu32 var32a;
;;;590    /*****************************内阻测量电压转换*******************************************/
;;;591    	var32 = Vmon1_value;
000002  4899              LDR      r0,|L2.616|
000004  6800              LDR      r0,[r0,#0]  ; Vmon1_value
;;;592    	var32 = var32 * REG_CorrectionV;  
000006  4a99              LDR      r2,|L2.620|
000008  6811              LDR      r1,[r2,#0]  ; Correct_Parametet
00000a  4341              MULS     r1,r0,r1
;;;593    	if ((Polar & 0x01) == 0x01)		  
00000c  4b98              LDR      r3,|L2.624|
00000e  7818              LDRB     r0,[r3,#0]  ; correct_por
000010  07c4              LSLS     r4,r0,#31
;;;594    	{
;;;595    		if (var32 < REG_ReadV_Offset) 
000012  f102002c          ADD      r0,r2,#0x2c
000016  d007              BEQ      |L2.40|
000018  6804              LDR      r4,[r0,#0]  ; Correct_Strong
00001a  428c              CMP      r4,r1
00001c  d901              BLS      |L2.34|
;;;596    		{
;;;597    			var32 = 0;
00001e  2100              MOVS     r1,#0
000020  e004              B        |L2.44|
                  |L2.34|
;;;598    		}
;;;599    		else var32 = var32 - REG_ReadV_Offset;
000022  6804              LDR      r4,[r0,#0]  ; Correct_Strong
000024  1b09              SUBS     r1,r1,r4
000026  e001              B        |L2.44|
                  |L2.40|
;;;600    	}
;;;601    	else var32 = var32 + REG_ReadV_Offset;
000028  6804              LDR      r4,[r0,#0]  ; Correct_Strong
00002a  4421              ADD      r1,r1,r4
                  |L2.44|
;;;602    	var32 = var32 >> 12;
00002c  0b09              LSRS     r1,r1,#12
;;;603    	if (var32 < 30) var32 = 0;				  //40mV以下清零
00002e  291e              CMP      r1,#0x1e
000030  d200              BCS      |L2.52|
000032  2100              MOVS     r1,#0
                  |L2.52|
;;;604    	Voltage = var32;
000034  4c8d              LDR      r4,|L2.620|
000036  3458              ADDS     r4,r4,#0x58
000038  62a1              STR      r1,[r4,#0x28]  ; Run_Control
;;;605    	DISS_Voltage=Voltage;
00003a  6aa1              LDR      r1,[r4,#0x28]  ; Run_Control
00003c  ee001a10          VMOV     s0,r1
000040  498c              LDR      r1,|L2.628|
000042  eef80a40          VCVT.F32.U32 s1,s0
;;;606    	DISS_Voltage=DISS_Voltage/1000;//计算显示电压
000046  ed9f0a8c          VLDR     s0,|L2.632|
00004a  ee801a80          VDIV.F32 s2,s1,s0
00004e  ed811a00          VSTR     s2,[r1,#0]
;;;607    	var32 = 0;
;;;608    	/*******************负载测量电流转换**************************************/
;;;609    	var32 = Imon1_value;
000052  498a              LDR      r1,|L2.636|
000054  680d              LDR      r5,[r1,#0]  ; Imon1_value
;;;610    	var32 = var32 * REG_Load_A;  
000056  6851              LDR      r1,[r2,#4]  ; Correct_Parametet
000058  4369              MULS     r1,r5,r1
;;;611    	if ((Polar1 & 0x01) == 0x01)		  
00005a  785d              LDRB     r5,[r3,#1]  ; correct_por
00005c  07ed              LSLS     r5,r5,#31
00005e  d007              BEQ      |L2.112|
;;;612    	{
;;;613    		if (var32 < REG_LoadA_Offset) 
000060  6845              LDR      r5,[r0,#4]  ; Correct_Strong
000062  428d              CMP      r5,r1
000064  d901              BLS      |L2.106|
;;;614    		{
;;;615    			var32 = 0;
000066  2100              MOVS     r1,#0
000068  e004              B        |L2.116|
                  |L2.106|
;;;616    		}
;;;617    		else var32 = var32 - REG_LoadA_Offset;
00006a  6845              LDR      r5,[r0,#4]  ; Correct_Strong
00006c  1b49              SUBS     r1,r1,r5
00006e  e001              B        |L2.116|
                  |L2.112|
;;;618    	}
;;;619    	else var32 = var32 + REG_LoadA_Offset;
000070  6845              LDR      r5,[r0,#4]  ; Correct_Strong
000072  4429              ADD      r1,r1,r5
                  |L2.116|
;;;620    	var32 = var32 >> 12;
000074  0b09              LSRS     r1,r1,#12
;;;621    	Laod_Current = var32;
000076  6321              STR      r1,[r4,#0x30]  ; Run_Control
;;;622    	DISS_Current=Laod_Current;
000078  6b21              LDR      r1,[r4,#0x30]  ; Run_Control
00007a  ee001a90          VMOV     s1,r1
00007e  4980              LDR      r1,|L2.640|
000080  eef80a60          VCVT.F32.U32 s1,s1
;;;623    	DISS_Current=DISS_Current/1000;//计算显示电流
000084  ee801a80          VDIV.F32 s2,s1,s0
000088  ed811a00          VSTR     s2,[r1,#0]
;;;624    	var32 = 0;	
;;;625    	/*************************负载电压和电流控制转换**************************************/
;;;626    	if(flag_Load_CC==1)
00008c  497d              LDR      r1,|L2.644|
;;;627    	{
;;;628    		var32 = SET_Current_Laod;
;;;629    		var32=var32<<12;   
;;;630    		if ((Polar1 & 0x04) == 0)			   
;;;631    		{
;;;632    			if (var32 < SET_LoadA_Offset) var32 = 0;
;;;633    			else var32 = var32 - SET_LoadA_Offset;
;;;634    		}
;;;635    		else var32 = var32 + SET_LoadA_Offset;
;;;636    		var32 = var32/SET_LoadA;
;;;637    		var32=var32>>1;
;;;638    		if(Flag_DAC_OFF==0)
;;;639    		{
;;;640    			Contr_Laod = var32;
00008e  4f7f              LDR      r7,|L2.652|
000090  f04f0500          MOV      r5,#0                 ;597
000094  6809              LDR      r1,[r1,#0]            ;626  ; flagD
000096  ea5f6c01          LSLS     r12,r1,#24            ;626
00009a  497b              LDR      r1,|L2.648|
00009c  680e              LDR      r6,[r1,#0]            ;626
00009e  d520              BPL      |L2.226|
0000a0  6921              LDR      r1,[r4,#0x10]         ;628  ; Run_Control
0000a2  0309              LSLS     r1,r1,#12             ;629
0000a4  f893c001          LDRB     r12,[r3,#1]           ;630  ; correct_por
0000a8  ea5f7c4c          LSLS     r12,r12,#29           ;630
0000ac  d40a              BMI      |L2.196|
0000ae  f8d0c008          LDR      r12,[r0,#8]           ;632  ; Correct_Strong
0000b2  458c              CMP      r12,r1                ;632
0000b4  d901              BLS      |L2.186|
0000b6  2100              MOVS     r1,#0                 ;632
0000b8  e007              B        |L2.202|
                  |L2.186|
0000ba  f8d0c008          LDR      r12,[r0,#8]           ;633  ; Correct_Strong
0000be  eba1010c          SUB      r1,r1,r12             ;633
0000c2  e002              B        |L2.202|
                  |L2.196|
0000c4  f8d0c008          LDR      r12,[r0,#8]           ;635  ; Correct_Strong
0000c8  4461              ADD      r1,r1,r12             ;635
                  |L2.202|
0000ca  f8d2c008          LDR      r12,[r2,#8]           ;636  ; Correct_Parametet
0000ce  fbb1f1fc          UDIV     r1,r1,r12             ;636
0000d2  0849              LSRS     r1,r1,#1              ;637
0000d4  0736              LSLS     r6,r6,#28             ;638
0000d6  d400              BMI      |L2.218|
0000d8  8039              STRH     r1,[r7,#0]
                  |L2.218|
;;;641    		}
;;;642    		if(SET_Current_Laod==0)
0000da  6921              LDR      r1,[r4,#0x10]  ; Run_Control
0000dc  bb09              CBNZ     r1,|L2.290|
;;;643    		{
;;;644    			Contr_Laod=0;
0000de  803d              STRH     r5,[r7,#0]
0000e0  e01f              B        |L2.290|
                  |L2.226|
;;;645    		}
;;;646    		var32 = 0;
;;;647    	}
;;;648    	else
;;;649    	{
;;;650    		var32 = SET_Voltage_Laod;
0000e2  68e1              LDR      r1,[r4,#0xc]  ; Run_Control
;;;651    		var32=var32<<12;   
0000e4  0309              LSLS     r1,r1,#12
;;;652    		if ((Polar2 & 0x04) == 0)			   
0000e6  f893c002          LDRB     r12,[r3,#2]  ; correct_por
0000ea  ea5f7c4c          LSLS     r12,r12,#29
0000ee  d40a              BMI      |L2.262|
;;;653    		{
;;;654    			if (var32 < SET_LoadA_Offset) var32 = 0;
0000f0  f8d0c008          LDR      r12,[r0,#8]  ; Correct_Strong
0000f4  458c              CMP      r12,r1
0000f6  d901              BLS      |L2.252|
0000f8  2100              MOVS     r1,#0
0000fa  e007              B        |L2.268|
                  |L2.252|
;;;655    			else var32 = var32 - SET_LoadV_Offset;
0000fc  f8d0c010          LDR      r12,[r0,#0x10]  ; Correct_Strong
000100  eba1010c          SUB      r1,r1,r12
000104  e002              B        |L2.268|
                  |L2.262|
;;;656    		}
;;;657    		else var32 = var32 + SET_LoadV_Offset;
000106  f8d0c010          LDR      r12,[r0,#0x10]  ; Correct_Strong
00010a  4461              ADD      r1,r1,r12
                  |L2.268|
;;;658    		var32 = var32/SET_LoadV;
00010c  f8d2c010          LDR      r12,[r2,#0x10]  ; Correct_Parametet
000110  fbb1f1fc          UDIV     r1,r1,r12
;;;659    		var32=var32>>1;
000114  0849              LSRS     r1,r1,#1
;;;660    		if(Flag_DAC_OFF==0)
000116  0736              LSLS     r6,r6,#28
000118  d400              BMI      |L2.284|
;;;661    		{
;;;662    			Contr_Laod = var32;
00011a  8039              STRH     r1,[r7,#0]
                  |L2.284|
;;;663    		}
;;;664    		if(SET_Voltage_Laod==0)
00011c  68e1              LDR      r1,[r4,#0xc]  ; Run_Control
00011e  b901              CBNZ     r1,|L2.290|
;;;665    		{
;;;666    			Contr_Laod=0;
000120  803d              STRH     r5,[r7,#0]
                  |L2.290|
;;;667    		}
;;;668    		var32 = 0;
;;;669    	}
;;;670    /*****************************内阻值转换*******************************************/
;;;671    	var32 = Rmon_value;
000122  495b              LDR      r1,|L2.656|
000124  880e              LDRH     r6,[r1,#0]  ; Rmon_value
;;;672    	var32 = var32 * REG_CorrectionR;  
000126  6951              LDR      r1,[r2,#0x14]  ; Correct_Parametet
000128  4371              MULS     r1,r6,r1
;;;673    	if ((Polar3 & 0x01) == 0x01)		  
00012a  78de              LDRB     r6,[r3,#3]  ; correct_por
00012c  07f6              LSLS     r6,r6,#31
00012e  d007              BEQ      |L2.320|
;;;674    	{
;;;675    		if (var32 < REG_ReadR_Offset) 
000130  6946              LDR      r6,[r0,#0x14]  ; Correct_Strong
000132  428e              CMP      r6,r1
000134  d901              BLS      |L2.314|
;;;676    		{
;;;677    			var32 = 0;
000136  2100              MOVS     r1,#0
000138  e004              B        |L2.324|
                  |L2.314|
;;;678    		}
;;;679    		else var32 = var32 - REG_ReadR_Offset;
00013a  6946              LDR      r6,[r0,#0x14]  ; Correct_Strong
00013c  1b89              SUBS     r1,r1,r6
00013e  e001              B        |L2.324|
                  |L2.320|
;;;680    	}
;;;681    	else var32 = var32 + REG_ReadR_Offset;
000140  6946              LDR      r6,[r0,#0x14]  ; Correct_Strong
000142  4431              ADD      r1,r1,r6
                  |L2.324|
;;;682    	var32 = var32 >> 12;
000144  0b09              LSRS     r1,r1,#12
;;;683    	if (var32 < 1)
;;;684    	{
;;;685    		var32 = 0;				  //清零
;;;686    	}
;;;687    	R_VLUE = var32;
000146  6361              STR      r1,[r4,#0x34]  ; Run_Control
;;;688    	var32 = 0;	
;;;689    	/*****************************稳压电源测量电压转换*******************************************/
;;;690    	var32 = Vmon_value;
000148  4952              LDR      r1,|L2.660|
00014a  880e              LDRH     r6,[r1,#0]  ; Vmon_value
;;;691    	var32 = var32 * REG_POWERV;  
00014c  6a11              LDR      r1,[r2,#0x20]  ; Correct_Parametet
00014e  4371              MULS     r1,r6,r1
;;;692    	if ((Polar5 & 0x01) == 0x01)		  
000150  795e              LDRB     r6,[r3,#5]  ; correct_por
000152  07f6              LSLS     r6,r6,#31
000154  d007              BEQ      |L2.358|
;;;693    	{
;;;694    		if (var32 < REG_POWERV_Offset) 
000156  6a06              LDR      r6,[r0,#0x20]  ; Correct_Strong
000158  428e              CMP      r6,r1
00015a  d901              BLS      |L2.352|
;;;695    		{
;;;696    			var32 = 0;
00015c  2100              MOVS     r1,#0
00015e  e004              B        |L2.362|
                  |L2.352|
;;;697    		}
;;;698    		else var32 = var32 - REG_POWERV_Offset;
000160  6a06              LDR      r6,[r0,#0x20]  ; Correct_Strong
000162  1b89              SUBS     r1,r1,r6
000164  e001              B        |L2.362|
                  |L2.358|
;;;699    	}
;;;700    	else var32 = var32 + REG_POWERV_Offset;
000166  6a06              LDR      r6,[r0,#0x20]  ; Correct_Strong
000168  4431              ADD      r1,r1,r6
                  |L2.362|
;;;701    	var32 = var32 >> 14;
00016a  0b89              LSRS     r1,r1,#14
;;;702    	if (var32 < 40) var32 = 0;				  //40mV以下清零
00016c  2928              CMP      r1,#0x28
00016e  d200              BCS      |L2.370|
000170  2100              MOVS     r1,#0
                  |L2.370|
;;;703    	POW_Voltage = var32;
000172  6261              STR      r1,[r4,#0x24]  ; Run_Control
;;;704    	DISS_POW_Voltage=POW_Voltage;
000174  6a61              LDR      r1,[r4,#0x24]  ; Run_Control
000176  ee001a90          VMOV     s1,r1
00017a  4947              LDR      r1,|L2.664|
00017c  eef80a60          VCVT.F32.U32 s1,s1
;;;705    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
000180  ed9f1a46          VLDR     s2,|L2.668|
000184  eec01a81          VDIV.F32 s3,s1,s2
000188  edc11a00          VSTR     s3,[r1,#0]
;;;706    	var32 = 0;
;;;707    /*****************************稳压电源测量电流转换*******************************************/
;;;708    	var32 = Imon_value;
00018c  4944              LDR      r1,|L2.672|
00018e  880e              LDRH     r6,[r1,#0]  ; Imon_value
;;;709    	if(flag_CC_MODE==1)
000190  4944              LDR      r1,|L2.676|
;;;710    	{
;;;711    		var32 = var32 * REG_POWERA;	   
;;;712    		if ((Polar4 & 0x01) == 0x01)			   
;;;713    		{
;;;714    			if (var32 < REG_POWERA_Offset) var32 = 0;
;;;715    			else var32 = var32 - REG_POWERA_Offset;
;;;716    		}
;;;717    		else
;;;718    		{
;;;719    			var32 = var32 + REG_POWERA_Offset;
;;;720    		}	
;;;721    		var32 = var32 >> 14;
;;;722    		Current = var32;;
;;;723    		DISS_POW_Current=Current;
000192  4f45              LDR      r7,|L2.680|
000194  6809              LDR      r1,[r1,#0]            ;709  ; flagE
000196  0609              LSLS     r1,r1,#24             ;709
000198  d51a              BPL      |L2.464|
00019a  6991              LDR      r1,[r2,#0x18]         ;711  ; Correct_Parametet
00019c  4371              MULS     r1,r6,r1              ;711
00019e  791e              LDRB     r6,[r3,#4]            ;712  ; correct_por
0001a0  07f6              LSLS     r6,r6,#31             ;712
0001a2  d007              BEQ      |L2.436|
0001a4  6986              LDR      r6,[r0,#0x18]         ;714  ; Correct_Strong
0001a6  428e              CMP      r6,r1                 ;714
0001a8  d901              BLS      |L2.430|
0001aa  2100              MOVS     r1,#0                 ;714
0001ac  e004              B        |L2.440|
                  |L2.430|
0001ae  6986              LDR      r6,[r0,#0x18]         ;715  ; Correct_Strong
0001b0  1b89              SUBS     r1,r1,r6              ;715
0001b2  e001              B        |L2.440|
                  |L2.436|
0001b4  6986              LDR      r6,[r0,#0x18]         ;719  ; Correct_Strong
0001b6  4431              ADD      r1,r1,r6              ;719
                  |L2.440|
0001b8  0b89              LSRS     r1,r1,#14             ;721
0001ba  62e1              STR      r1,[r4,#0x2c]         ;722  ; Run_Control
0001bc  6ae1              LDR      r1,[r4,#0x2c]  ; Run_Control
0001be  ee001a90          VMOV     s1,r1
0001c2  eef80a60          VCVT.F32.U32 s1,s1
;;;724    		DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0001c6  ee801a80          VDIV.F32 s2,s1,s0
0001ca  ed871a00          VSTR     s2,[r7,#0]
0001ce  e019              B        |L2.516|
                  |L2.464|
;;;725    	}
;;;726    	else
;;;727    	{
;;;728    		var32 = var32 * CON_POWERA;	   
0001d0  6a91              LDR      r1,[r2,#0x28]  ; Correct_Parametet
0001d2  4371              MULS     r1,r6,r1
;;;729    		if ((Polar3 & 0x04) == 0x04)			   
0001d4  78de              LDRB     r6,[r3,#3]  ; correct_por
0001d6  0776              LSLS     r6,r6,#29
0001d8  d507              BPL      |L2.490|
;;;730    		{
;;;731    			if (var32 < CON_POWERA_Offset) var32 = 0;
0001da  6a86              LDR      r6,[r0,#0x28]  ; Correct_Strong
0001dc  428e              CMP      r6,r1
0001de  d901              BLS      |L2.484|
0001e0  2100              MOVS     r1,#0
0001e2  e004              B        |L2.494|
                  |L2.484|
;;;732    			else var32 = var32 - CON_POWERA_Offset;
0001e4  6a86              LDR      r6,[r0,#0x28]  ; Correct_Strong
0001e6  1b89              SUBS     r1,r1,r6
0001e8  e001              B        |L2.494|
                  |L2.490|
;;;733    		}
;;;734    		else
;;;735    		{
;;;736    			var32 = var32 + CON_POWERA_Offset;
0001ea  6a86              LDR      r6,[r0,#0x28]  ; Correct_Strong
0001ec  4431              ADD      r1,r1,r6
                  |L2.494|
;;;737    		}	
;;;738    		var32 = var32 >> 14;
0001ee  0b89              LSRS     r1,r1,#14
;;;739    		Current = var32;;
0001f0  62e1              STR      r1,[r4,#0x2c]  ; Run_Control
;;;740    		DISS_POW_Current=Current;
0001f2  6ae1              LDR      r1,[r4,#0x2c]  ; Run_Control
0001f4  ee001a90          VMOV     s1,r1
0001f8  eef80a60          VCVT.F32.U32 s1,s1
;;;741    		DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0001fc  ee801a80          VDIV.F32 s2,s1,s0
000200  ed871a00          VSTR     s2,[r7,#0]
                  |L2.516|
;;;742    	}
;;;743    /**************************稳压电源设置电压转换******************************************/
;;;744    	var32 = SET_Voltage;
000204  6861              LDR      r1,[r4,#4]  ; Run_Control
;;;745    	var32=var32<<14;   
000206  0389              LSLS     r1,r1,#14
;;;746    	if ((Polar5 & 0x04) == 0)			   
000208  795e              LDRB     r6,[r3,#5]  ; correct_por
00020a  0776              LSLS     r6,r6,#29
00020c  d407              BMI      |L2.542|
;;;747    	{
;;;748    		if (var32 < SET_POWERV_Offset) var32 = 0;
00020e  6a46              LDR      r6,[r0,#0x24]  ; Correct_Strong
000210  428e              CMP      r6,r1
000212  d901              BLS      |L2.536|
000214  2100              MOVS     r1,#0
000216  e004              B        |L2.546|
                  |L2.536|
;;;749    		else var32 = var32 - SET_POWERV_Offset;
000218  6a46              LDR      r6,[r0,#0x24]  ; Correct_Strong
00021a  1b89              SUBS     r1,r1,r6
00021c  e001              B        |L2.546|
                  |L2.542|
;;;750    	}
;;;751    	else var32 = var32 + SET_POWERV_Offset;
00021e  6a46              LDR      r6,[r0,#0x24]  ; Correct_Strong
000220  4431              ADD      r1,r1,r6
                  |L2.546|
;;;752    	var32 = var32/SET_POWERV;
000222  6a56              LDR      r6,[r2,#0x24]  ; Correct_Parametet
000224  fbb1f1f6          UDIV     r1,r1,r6
;;;753    	var32=var32>>1;
000228  0849              LSRS     r1,r1,#1
;;;754    	Contr_Voltage = var32;
00022a  4e20              LDR      r6,|L2.684|
00022c  8031              STRH     r1,[r6,#0]
;;;755    	if(SET_Voltage==0)
00022e  6861              LDR      r1,[r4,#4]  ; Run_Control
000230  b901              CBNZ     r1,|L2.564|
;;;756    	{
;;;757    		Contr_Voltage=0;
000232  8035              STRH     r5,[r6,#0]
                  |L2.564|
;;;758    	}
;;;759    	var32 = 0;
;;;760    /**************************稳压电源设置电流转换**************************************/
;;;761    	var32 = SET_Current;
000234  68a1              LDR      r1,[r4,#8]  ; Run_Control
;;;762    	var32=var32<<14;   
000236  0389              LSLS     r1,r1,#14
;;;763    	if ((Polar4 & 0x04) == 0)			   
000238  791b              LDRB     r3,[r3,#4]  ; correct_por
00023a  075b              LSLS     r3,r3,#29
00023c  d407              BMI      |L2.590|
;;;764    	{
;;;765    		if (var32 < SET_POWERA_Offset) var32 = 0;
00023e  69c3              LDR      r3,[r0,#0x1c]  ; Correct_Strong
000240  428b              CMP      r3,r1
000242  d901              BLS      |L2.584|
000244  2000              MOVS     r0,#0
000246  e004              B        |L2.594|
                  |L2.584|
;;;766    		else var32 = var32 - SET_POWERA_Offset;
000248  69c0              LDR      r0,[r0,#0x1c]  ; Correct_Strong
00024a  1a08              SUBS     r0,r1,r0
00024c  e001              B        |L2.594|
                  |L2.590|
;;;767    	}
;;;768    	else var32 = var32 + SET_POWERA_Offset;
00024e  69c0              LDR      r0,[r0,#0x1c]  ; Correct_Strong
000250  4408              ADD      r0,r0,r1
                  |L2.594|
;;;769    	var32 = var32/SET_POWERA;
000252  69d1              LDR      r1,[r2,#0x1c]  ; Correct_Parametet
000254  fbb0f0f1          UDIV     r0,r0,r1
;;;770    	var32=var32>>1;
000258  0840              LSRS     r0,r0,#1
;;;771    	Contr_Current = var32;
00025a  4915              LDR      r1,|L2.688|
00025c  8008              STRH     r0,[r1,#0]
;;;772    	if(SET_Current==0)
00025e  68a0              LDR      r0,[r4,#8]  ; Run_Control
000260  2800              CMP      r0,#0
000262  d100              BNE      |L2.614|
;;;773    	{
;;;774    		Contr_Current=0;
000264  800d              STRH     r5,[r1,#0]
                  |L2.614|
;;;775    	}
;;;776    	
;;;777    	var32 = 0;
;;;778    }
000266  bdf0              POP      {r4-r7,pc}
;;;779    /********************************************************************************
                          ENDP

                  |L2.616|
                          DCD      Vmon1_value
                  |L2.620|
                          DCD      ||.bss||
                  |L2.624|
                          DCD      ||area_number.8||+0x1c
                  |L2.628|
                          DCD      DISS_Voltage
                  |L2.632|
000278  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.636|
                          DCD      Imon1_value
                  |L2.640|
                          DCD      DISS_Current
                  |L2.644|
                          DCD      flagD
                  |L2.648|
                          DCD      flagB
                  |L2.652|
                          DCD      Contr_Laod
                  |L2.656|
                          DCD      Rmon_value
                  |L2.660|
                          DCD      Vmon_value
                  |L2.664|
                          DCD      DISS_POW_Voltage
                  |L2.668|
00029c  42c80000          DCFS     0x42c80000 ; 100
                  |L2.672|
                          DCD      Imon_value
                  |L2.676|
                          DCD      flagE
                  |L2.680|
                          DCD      DISS_POW_Current
                  |L2.684|
                          DCD      Contr_Voltage
                  |L2.688|
                          DCD      Contr_Current

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;44     //===========================MODBUS协议=============================//
;;;45     void UART_Action(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;46     {//RUT格式：
;;;47     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;48     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;49     	if (UART_Buffer_Rece[0] == ADDR)
000004  f8dfa3f8          LDR      r10,|L3.1024|
000008  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
00000c  4efd              LDR      r6,|L3.1028|
00000e  7871              LDRB     r1,[r6,#1]  ; ADDR
;;;50     	{
;;;51     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;52     		{																		 
;;;53     			vu8 i;
;;;54     			vu16 crc_result;
;;;55     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;56     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;57     			{
;;;58     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;59     				{
;;;60     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;61     					{							
;;;62     						UART_Buffer_Send[0] = ADDR;
000010  4dfd              LDR      r5,|L3.1032|
;;;63     						UART_Buffer_Send[1] = 0x03;
;;;64     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;65     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;66     						{
;;;67     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;68     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;69     						}
;;;70     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;71     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;72     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;73     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
000012  f8df93f8          LDR      r9,|L3.1036|
;;;74     						UART_SEND_flag=1;
000016  4ffe              LDR      r7,|L3.1040|
000018  f8df83f8          LDR      r8,|L3.1044|
00001c  4288              CMP      r0,r1                 ;49
00001e  d14b              BNE      |L3.184|
000020  f89a0001          LDRB     r0,[r10,#1]           ;51  ; UART_Buffer_Rece
000024  2803              CMP      r0,#3                 ;51
000026  d147              BNE      |L3.184|
000028  f89a0007          LDRB     r0,[r10,#7]           ;55  ; UART_Buffer_Rece
00002c  f89a1006          LDRB     r1,[r10,#6]           ;55  ; UART_Buffer_Rece
000030  eb002001          ADD      r0,r0,r1,LSL #8       ;55
000034  b284              UXTH     r4,r0                 ;55
000036  2106              MOVS     r1,#6                 ;56
000038  4650              MOV      r0,r10                ;56
00003a  f7fffffe          BL       Hardware_CRC
00003e  42a0              CMP      r0,r4                 ;56
000040  d000              BEQ      |L3.68|
000042  bbcc              CBNZ     r4,|L3.184|
                  |L3.68|
000044  f89a0003          LDRB     r0,[r10,#3]           ;58  ; UART_Buffer_Rece
000048  2807              CMP      r0,#7                 ;58
00004a  d235              BCS      |L3.184|
00004c  f89a0003          LDRB     r0,[r10,#3]           ;60  ; UART_Buffer_Rece
000050  f89a1005          LDRB     r1,[r10,#5]           ;60  ; UART_Buffer_Rece
000054  4408              ADD      r0,r0,r1              ;60
000056  280f              CMP      r0,#0xf               ;60
000058  d22e              BCS      |L3.184|
00005a  7870              LDRB     r0,[r6,#1]            ;62  ; ADDR
00005c  7028              STRB     r0,[r5,#0]            ;62
00005e  2003              MOVS     r0,#3                 ;63
000060  7068              STRB     r0,[r5,#1]            ;63
000062  f89a0005          LDRB     r0,[r10,#5]           ;64  ; UART_Buffer_Rece
000066  0040              LSLS     r0,r0,#1              ;64
000068  70a8              STRB     r0,[r5,#2]            ;64
00006a  2000              MOVS     r0,#0                 ;65
00006c  e00b              B        |L3.134|
                  |L3.110|
00006e  07c1              LSLS     r1,r0,#31             ;67
000070  d03d              BEQ      |L3.238|
000072  f89a1003          LDRB     r1,[r10,#3]           ;68  ; UART_Buffer_Rece
000076  eb010150          ADD      r1,r1,r0,LSR #1       ;68
00007a  f8581021          LDR      r1,[r8,r1,LSL #2]     ;68
00007e  182a              ADDS     r2,r5,r0              ;68
000080  70d1              STRB     r1,[r2,#3]            ;68
                  |L3.130|
000082  1c40              ADDS     r0,r0,#1              ;65
000084  b2c0              UXTB     r0,r0                 ;65
                  |L3.134|
000086  78a9              LDRB     r1,[r5,#2]            ;65  ; UART_Buffer_Send
000088  4281              CMP      r1,r0                 ;65
00008a  d8f0              BHI      |L3.110|
00008c  78a8              LDRB     r0,[r5,#2]            ;70  ; UART_Buffer_Send
00008e  1cc0              ADDS     r0,r0,#3              ;70
000090  b2c1              UXTB     r1,r0                 ;70
000092  48dd              LDR      r0,|L3.1032|
000094  f7fffffe          BL       Hardware_CRC
000098  78ab              LDRB     r3,[r5,#2]            ;71  ; UART_Buffer_Send
00009a  0a02              LSRS     r2,r0,#8              ;71
00009c  49da              LDR      r1,|L3.1032|
00009e  1cc9              ADDS     r1,r1,#3              ;71
0000a0  545a              STRB     r2,[r3,r1]            ;71
0000a2  78aa              LDRB     r2,[r5,#2]            ;72  ; UART_Buffer_Send
0000a4  1c49              ADDS     r1,r1,#1              ;72
0000a6  5450              STRB     r0,[r2,r1]            ;72
0000a8  78a8              LDRB     r0,[r5,#2]            ;73  ; UART_Buffer_Send
0000aa  1d40              ADDS     r0,r0,#5              ;73
0000ac  f8890000          STRB     r0,[r9,#0]            ;73
0000b0  6838              LDR      r0,[r7,#0]  ; flagA
0000b2  f0400010          ORR      r0,r0,#0x10
0000b6  6038              STR      r0,[r7,#0]  ; flagA
                  |L3.184|
;;;75     					}
;;;76     				}
;;;77     			}	
;;;78     		}
;;;79     	} 
;;;80     //===============================写寄存器=================================
;;;81     	if ((UART_Buffer_Rece[0] == 0) || (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000b8  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0000bc  b180              CBZ      r0,|L3.224|
0000be  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0000c2  7871              LDRB     r1,[r6,#1]  ; ADDR
0000c4  4288              CMP      r0,r1
0000c6  d00b              BEQ      |L3.224|
0000c8  7870              LDRB     r0,[r6,#1]  ; ADDR
0000ca  1e40              SUBS     r0,r0,#1
0000cc  17c1              ASRS     r1,r0,#31
0000ce  eb007091          ADD      r0,r0,r1,LSR #30
0000d2  2164              MOVS     r1,#0x64
0000d4  eb0100a0          ADD      r0,r1,r0,ASR #2
0000d8  f89a1000          LDRB     r1,[r10,#0]  ; UART_Buffer_Rece
0000dc  4288              CMP      r0,r1
0000de  d17d              BNE      |L3.476|
                  |L3.224|
;;;82     	{
;;;83     		vu8 var8;
;;;84     		vu8 a=0;
;;;85     		vu16 var16;
;;;86     		vu16 crc_result;
;;;87     //=========================以下命令6 写单个寄存器===========================
;;;88     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
0000e0  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;89     		{
;;;90     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;91     			{
;;;92     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;93     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;94     				{
;;;95     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;96     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;97     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;98     
;;;99     					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;100    					{
;;;101    						for (a=0;a<8;a++)
;;;102    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;103    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
0000e4  f04f0b08          MOV      r11,#8
0000e8  2806              CMP      r0,#6                 ;88
0000ea  d00a              BEQ      |L3.258|
0000ec  e03a              B        |L3.356|
                  |L3.238|
0000ee  f89a1003          LDRB     r1,[r10,#3]           ;67  ; UART_Buffer_Rece
0000f2  eb010150          ADD      r1,r1,r0,LSR #1       ;67
0000f6  f8581021          LDR      r1,[r8,r1,LSL #2]     ;67
0000fa  0a09              LSRS     r1,r1,#8              ;67
0000fc  182a              ADDS     r2,r5,r0              ;67
0000fe  70d1              STRB     r1,[r2,#3]            ;67
000100  e7bf              B        |L3.130|
                  |L3.258|
000102  f89a0003          LDRB     r0,[r10,#3]           ;90  ; UART_Buffer_Rece
000106  2805              CMP      r0,#5                 ;90
000108  d22c              BCS      |L3.356|
00010a  f89a0007          LDRB     r0,[r10,#7]           ;92  ; UART_Buffer_Rece
00010e  f89a1006          LDRB     r1,[r10,#6]           ;92  ; UART_Buffer_Rece
000112  eb002001          ADD      r0,r0,r1,LSL #8       ;92
000116  b284              UXTH     r4,r0                 ;92
000118  2106              MOVS     r1,#6                 ;93
00011a  48b9              LDR      r0,|L3.1024|
00011c  f7fffffe          BL       Hardware_CRC
000120  42a0              CMP      r0,r4                 ;93
000122  d000              BEQ      |L3.294|
000124  b9f4              CBNZ     r4,|L3.356|
                  |L3.294|
000126  f89a0005          LDRB     r0,[r10,#5]           ;95  ; UART_Buffer_Rece
00012a  f89a1004          LDRB     r1,[r10,#4]           ;95  ; UART_Buffer_Rece
00012e  eb002001          ADD      r0,r0,r1,LSL #8       ;95
000132  b280              UXTH     r0,r0                 ;95
000134  f89a1003          LDRB     r1,[r10,#3]           ;96  ; UART_Buffer_Rece
000138  f8480021          STR      r0,[r8,r1,LSL #2]     ;97
00013c  f89a0000          LDRB     r0,[r10,#0]           ;99  ; UART_Buffer_Rece
000140  7871              LDRB     r1,[r6,#1]            ;99  ; ADDR
000142  4288              CMP      r0,r1                 ;99
000144  d10e              BNE      |L3.356|
000146  2000              MOVS     r0,#0                 ;101
000148  e004              B        |L3.340|
                  |L3.330|
00014a  f81a1000          LDRB     r1,[r10,r0]           ;102
00014e  5429              STRB     r1,[r5,r0]            ;102
000150  1c40              ADDS     r0,r0,#1              ;101
000152  b2c0              UXTB     r0,r0                 ;101
                  |L3.340|
000154  2808              CMP      r0,#8                 ;101
000156  d3f8              BCC      |L3.330|
000158  f889b000          STRB     r11,[r9,#0]
;;;104    						UART_SEND_flag=1;
00015c  6838              LDR      r0,[r7,#0]  ; flagA
00015e  f0400010          ORR      r0,r0,#0x10
000162  6038              STR      r0,[r7,#0]  ; flagA
                  |L3.356|
;;;105    					}
;;;106    				}
;;;107    			}
;;;108    		}
;;;109    //=======================================以下是命令16，连写寄存器===========================================
;;;110    //功能码16格式:
;;;111    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;112    //返回数据格式:
;;;113    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;114    		if (UART_Buffer_Rece[1] == 16)										  
000164  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
000168  2810              CMP      r0,#0x10
00016a  d146              BNE      |L3.506|
;;;115    		{	
;;;116    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
00016c  f89a0006          LDRB     r0,[r10,#6]  ; UART_Buffer_Rece
000170  2806              CMP      r0,#6
000172  d142              BNE      |L3.506|
000174  f89a0003          LDRB     r0,[r10,#3]  ; UART_Buffer_Rece
000178  bb80              CBNZ     r0,|L3.476|
;;;117    			{
;;;118    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
00017a  f89a000e          LDRB     r0,[r10,#0xe]  ; UART_Buffer_Rece
00017e  f89a100d          LDRB     r1,[r10,#0xd]  ; UART_Buffer_Rece
000182  eb002001          ADD      r0,r0,r1,LSL #8
000186  b284              UXTH     r4,r0
;;;119    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
000188  210d              MOVS     r1,#0xd
00018a  489d              LDR      r0,|L3.1024|
00018c  f7fffffe          BL       Hardware_CRC
000190  42a0              CMP      r0,r4
000192  d000              BEQ      |L3.406|
000194  bb14              CBNZ     r4,|L3.476|
                  |L3.406|
;;;120    				{												
;;;121    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
000196  2000              MOVS     r0,#0
000198  e009              B        |L3.430|
                  |L3.410|
00019a  eb0a0140          ADD      r1,r10,r0,LSL #1
00019e  7a0a              LDRB     r2,[r1,#8]
0001a0  79c9              LDRB     r1,[r1,#7]
0001a2  eb022101          ADD      r1,r2,r1,LSL #8
0001a6  f8481020          STR      r1,[r8,r0,LSL #2]
0001aa  1c40              ADDS     r0,r0,#1
0001ac  b2c0              UXTB     r0,r0
                  |L3.430|
0001ae  2803              CMP      r0,#3
0001b0  d3f3              BCC      |L3.410|
;;;122    
;;;123    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
0001b2  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0001b6  7871              LDRB     r1,[r6,#1]  ; ADDR
0001b8  4288              CMP      r0,r1
0001ba  d11e              BNE      |L3.506|
;;;124    					{
;;;125    						UART_Buffer_Send[0] = ADDR;
0001bc  7870              LDRB     r0,[r6,#1]  ; ADDR
0001be  7028              STRB     r0,[r5,#0]
;;;126    						UART_Buffer_Send[1] = 16;
0001c0  2010              MOVS     r0,#0x10
0001c2  7068              STRB     r0,[r5,#1]
;;;127    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
0001c4  f89a0002          LDRB     r0,[r10,#2]  ; UART_Buffer_Rece
0001c8  70a8              STRB     r0,[r5,#2]
;;;128    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
0001ca  f89a0003          LDRB     r0,[r10,#3]  ; UART_Buffer_Rece
0001ce  70e8              STRB     r0,[r5,#3]
;;;129    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
0001d0  f89a0004          LDRB     r0,[r10,#4]  ; UART_Buffer_Rece
0001d4  7128              STRB     r0,[r5,#4]
;;;130    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
0001d6  f89a0005          LDRB     r0,[r10,#5]  ; UART_Buffer_Rece
0001da  e000              B        |L3.478|
                  |L3.476|
0001dc  e00d              B        |L3.506|
                  |L3.478|
0001de  7168              STRB     r0,[r5,#5]
;;;131    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
0001e0  2106              MOVS     r1,#6
0001e2  4889              LDR      r0,|L3.1032|
0001e4  f7fffffe          BL       Hardware_CRC
;;;132    						UART_Buffer_Send[6] = crc_result>>8;
0001e8  0a01              LSRS     r1,r0,#8
0001ea  71a9              STRB     r1,[r5,#6]
;;;133    						UART_Buffer_Send[7] = crc_result;				 
0001ec  71e8              STRB     r0,[r5,#7]
;;;134    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
0001ee  f889b000          STRB     r11,[r9,#0]
;;;135    						UART_SEND_flag=1;
0001f2  6838              LDR      r0,[r7,#0]  ; flagA
0001f4  f0400010          ORR      r0,r0,#0x10
0001f8  6038              STR      r0,[r7,#0]  ; flagA
                  |L3.506|
;;;136    					}
;;;137    				}
;;;138    			}			 
;;;139    		}
;;;140    	}
;;;141    /*************************************以下为校准部分**************************************************************************/
;;;142    	if (((UART_Buffer_Rece[0] == 0x01)&&(UART_Buffer_Rece[2] == 0xA5))||(flag_ADJ_ON==1))			   //电压校准
0001fa  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0001fe  f8df9218          LDR      r9,|L3.1048|
000202  2801              CMP      r0,#1
000204  d103              BNE      |L3.526|
000206  f89a0002          LDRB     r0,[r10,#2]  ; UART_Buffer_Rece
00020a  28a5              CMP      r0,#0xa5
00020c  d003              BEQ      |L3.534|
                  |L3.526|
00020e  f8d90000          LDR      r0,[r9,#0]  ; flagF
000212  0780              LSLS     r0,r0,#30
000214  d57e              BPL      |L3.788|
                  |L3.534|
;;;143    	{ 
;;;144    		if(UART_Buffer_Rece[1] == 0x01)
000216  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;145    		{
;;;146    			flag_ADJ_VL=0;
;;;147    			Modify_A_READ = Vmon1_value;//测量电压值
00021a  f8dfb200          LDR      r11,|L3.1052|
00021e  2801              CMP      r0,#1                 ;144
000220  d10f              BNE      |L3.578|
000222  f8d90000          LDR      r0,[r9,#0]            ;146  ; flagF
000226  f0200004          BIC      r0,r0,#4              ;146
00022a  f8c90000          STR      r0,[r9,#0]            ;146  ; flagF
00022e  f8db0000          LDR      r0,[r11,#0]  ; Vmon1_value
000232  6070              STR      r0,[r6,#4]  ; Modify_A_READ
;;;148    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000234  f89a0004          LDRB     r0,[r10,#4]  ; UART_Buffer_Rece
000238  f89a1003          LDRB     r1,[r10,#3]  ; UART_Buffer_Rece
00023c  eb002001          ADD      r0,r0,r1,LSL #8
000240  60f0              STR      r0,[r6,#0xc]  ; Modify_A_ACT
                  |L3.578|
;;;149    		}
;;;150    		if (UART_Buffer_Rece[1] == 0x02)			   //电压测量校准完成
000242  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;151    		{
;;;152    			vu32 var16;
;;;153    			vu32 var32a;
;;;154    			vu32 var32b;
;;;155    			
;;;156    			vu32 var16a;
;;;157    			vu32 var32c;
;;;158    			vu32 var32d;
;;;159    			Modify_B_READ =Vmon1_value;//测量电压值
;;;160    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
;;;161    			var32a = Modify_B_ACT;
;;;162    			var32a = var32a - Modify_A_ACT;
;;;163    			var32a = var32a << 12;
;;;164    			var16 = Modify_B_READ - Modify_A_READ;
;;;165    			var32a = var32a / var16;
;;;166    			REG_CorrectionV = var32a;
000246  f8df81cc          LDR      r8,|L3.1044|
;;;167    			var32a=0;
;;;168    			var32a = Modify_B_ACT;
;;;169    			var32a = var32a << 12;
;;;170    			var32b = Modify_B_READ;
;;;171    			var32b = var32b * REG_CorrectionV;
;;;172    			if (var32a < var32b)
;;;173    			{
;;;174    				var32b = var32b - var32a;
;;;175    				REG_ReadV_Offset = var32b;
;;;176    				Polar |= 0x01;
00024a  4c6e              LDR      r4,|L3.1028|
00024c  f1a80858          SUB      r8,r8,#0x58           ;166
000250  341c              ADDS     r4,r4,#0x1c
;;;177    			}
;;;178    			else 
;;;179    			{
;;;180    				var32a = var32a - var32b;
;;;181    				REG_ReadV_Offset = var32a;
;;;182    				Polar &= ~0x01;
;;;183    			}			
;;;184    			Flash_Write_all();	//参数写进FLASH
;;;185    			Flag_DAC_OFF=0;
000252  4f73              LDR      r7,|L3.1056|
000254  f108052c          ADD      r5,r8,#0x2c           ;175
000258  2802              CMP      r0,#2                 ;150
00025a  d12f              BNE      |L3.700|
00025c  f8db0000          LDR      r0,[r11,#0]           ;159  ; Vmon1_value
000260  6130              STR      r0,[r6,#0x10]         ;159  ; Modify_B_READ
000262  f89a0004          LDRB     r0,[r10,#4]           ;160  ; UART_Buffer_Rece
000266  f89a1003          LDRB     r1,[r10,#3]           ;160  ; UART_Buffer_Rece
00026a  eb002001          ADD      r0,r0,r1,LSL #8       ;160
00026e  61b0              STR      r0,[r6,#0x18]         ;160  ; Modify_B_ACT
000270  69b0              LDR      r0,[r6,#0x18]         ;161  ; Modify_B_ACT
000272  68f1              LDR      r1,[r6,#0xc]          ;162  ; Modify_A_ACT
000274  1a40              SUBS     r0,r0,r1              ;162
000276  0301              LSLS     r1,r0,#12             ;163
000278  6930              LDR      r0,[r6,#0x10]         ;164  ; Modify_B_READ
00027a  6872              LDR      r2,[r6,#4]            ;164  ; Modify_A_READ
00027c  1a80              SUBS     r0,r0,r2              ;164
00027e  fbb1f0f0          UDIV     r0,r1,r0              ;165
000282  f8c80000          STR      r0,[r8,#0]            ;166  ; Correct_Parametet
000286  69b0              LDR      r0,[r6,#0x18]         ;168  ; Modify_B_ACT
000288  0301              LSLS     r1,r0,#12             ;169
00028a  6932              LDR      r2,[r6,#0x10]         ;170  ; Modify_B_READ
00028c  f8d80000          LDR      r0,[r8,#0]            ;171  ; Correct_Parametet
000290  4350              MULS     r0,r2,r0              ;171
000292  4281              CMP      r1,r0                 ;172
000294  d206              BCS      |L3.676|
000296  1a40              SUBS     r0,r0,r1              ;174
000298  6028              STR      r0,[r5,#0]            ;175  ; Correct_Strong
00029a  7820              LDRB     r0,[r4,#0]            ;176  ; correct_por
00029c  f0400001          ORR      r0,r0,#1              ;176
0002a0  7020              STRB     r0,[r4,#0]            ;176
0002a2  e005              B        |L3.688|
                  |L3.676|
0002a4  1a08              SUBS     r0,r1,r0              ;180
0002a6  6028              STR      r0,[r5,#0]            ;181  ; Correct_Strong
0002a8  7820              LDRB     r0,[r4,#0]            ;182  ; correct_por
0002aa  f0200001          BIC      r0,r0,#1              ;182
0002ae  7020              STRB     r0,[r4,#0]            ;182
                  |L3.688|
0002b0  f7fffffe          BL       Flash_Write_all
0002b4  6838              LDR      r0,[r7,#0]  ; flagB
0002b6  f0200008          BIC      r0,r0,#8
0002ba  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.700|
;;;186    		}
;;;187    		
;;;188    		
;;;189    /************************************负载电流测量和控制校准*****************************************************************/
;;;190    		if (UART_Buffer_Rece[1] == 0x03)			   //CC模式校准
0002bc  f89a2001          LDRB     r2,[r10,#1]  ; UART_Buffer_Rece
0002c0  4650              MOV      r0,r10
;;;191    		{
;;;192    			Modify_A_READ = Imon1_value;//
0002c2  4958              LDR      r1,|L3.1060|
;;;193    			Modify_C_READ = Contr_Laod;//
0002c4  f8dfa160          LDR      r10,|L3.1064|
0002c8  2a03              CMP      r2,#3                 ;190
0002ca  d10d              BNE      |L3.744|
0002cc  680a              LDR      r2,[r1,#0]            ;192  ; Imon1_value
0002ce  6072              STR      r2,[r6,#4]            ;192  ; Modify_A_READ
0002d0  f8ba2000          LDRH     r2,[r10,#0]  ; Contr_Laod
0002d4  60b2              STR      r2,[r6,#8]  ; Modify_C_READ
;;;194    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0002d6  7902              LDRB     r2,[r0,#4]  ; UART_Buffer_Rece
0002d8  78c3              LDRB     r3,[r0,#3]  ; UART_Buffer_Rece
0002da  eb022203          ADD      r2,r2,r3,LSL #8
0002de  60f2              STR      r2,[r6,#0xc]  ; Modify_A_ACT
;;;195    			Flag_DAC_OFF=1;//
0002e0  683a              LDR      r2,[r7,#0]  ; flagB
0002e2  f0420208          ORR      r2,r2,#8
0002e6  603a              STR      r2,[r7,#0]  ; flagB
                  |L3.744|
;;;196    		}
;;;197    
;;;198    		if (UART_Buffer_Rece[1] == 0x04)			   //
0002e8  4845              LDR      r0,|L3.1024|
0002ea  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
0002ec  2804              CMP      r0,#4
0002ee  d154              BNE      |L3.922|
;;;199    		{
;;;200    			vu32 var16;
;;;201    			vu32 var32a;
;;;202    			vu32 var32b;
;;;203    			
;;;204    			vu32 var16a;
;;;205    			vu32 var32c;
;;;206    			vu32 var32d;
;;;207    			
;;;208    			Modify_B_READ = Imon1_value;
0002f0  6808              LDR      r0,[r1,#0]  ; Imon1_value
0002f2  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;209    			Modify_D_READ = Contr_Laod;
0002f4  f8ba0000          LDRH     r0,[r10,#0]  ; Contr_Laod
0002f8  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;210    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0002fa  4841              LDR      r0,|L3.1024|
0002fc  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
0002fe  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
000300  eb012000          ADD      r0,r1,r0,LSL #8
000304  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;211    			
;;;212    			var32a = Modify_B_ACT;
000306  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;213    			var32a = var32a - Modify_A_ACT;
000308  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00030a  1a40              SUBS     r0,r0,r1
;;;214    			var32a = var32a << 12;
00030c  0301              LSLS     r1,r0,#12
;;;215    			var16 = Modify_B_READ - Modify_A_READ;
00030e  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000310  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
000312  e000              B        |L3.790|
                  |L3.788|
000314  e26f              B        |L3.2038|
                  |L3.790|
000316  1a80              SUBS     r0,r0,r2
;;;216    			var32a = var32a / var16;
000318  fbb1f0f0          UDIV     r0,r1,r0
;;;217    			REG_Load_A = var32a;
00031c  f8c80004          STR      r0,[r8,#4]  ; Correct_Parametet
;;;218    			var32a = Modify_B_ACT;
000320  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;219    			var32a = var32a << 12;
000322  0301              LSLS     r1,r0,#12
;;;220    			var32b = Modify_B_READ;
000324  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;221    			var32b = var32b * REG_Load_A;
000326  f8d80004          LDR      r0,[r8,#4]  ; Correct_Parametet
00032a  4350              MULS     r0,r2,r0
;;;222    			if (var32a < var32b)
00032c  4281              CMP      r1,r0
00032e  d206              BCS      |L3.830|
;;;223    			{
;;;224    				var32b = var32b - var32a;
000330  1a40              SUBS     r0,r0,r1
;;;225    				REG_LoadA_Offset = var32b;
000332  6068              STR      r0,[r5,#4]  ; Correct_Strong
;;;226    				Polar1 |= 0x01;
000334  7860              LDRB     r0,[r4,#1]  ; correct_por
000336  f0400001          ORR      r0,r0,#1
00033a  7060              STRB     r0,[r4,#1]
00033c  e005              B        |L3.842|
                  |L3.830|
;;;227    			}
;;;228    			else 
;;;229    			{
;;;230    				var32a = var32a - var32b;
00033e  1a08              SUBS     r0,r1,r0
;;;231    				REG_LoadA_Offset = var32a;
000340  6068              STR      r0,[r5,#4]  ; Correct_Strong
;;;232    				Polar1 &= ~0x01;					
000342  7860              LDRB     r0,[r4,#1]  ; correct_por
000344  f0200001          BIC      r0,r0,#1
000348  7060              STRB     r0,[r4,#1]
                  |L3.842|
;;;233    			}
;;;234    //---------------------------------------------------------------------------------//
;;;235    			var32c = Modify_B_ACT; 
00034a  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;236    			var32c = var32c - Modify_A_ACT;
00034c  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00034e  1a40              SUBS     r0,r0,r1
;;;237    			var32c = var32c << 12;
000350  0300              LSLS     r0,r0,#12
;;;238    			var16a=Modify_D_READ-Modify_C_READ;
000352  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
000354  68b2              LDR      r2,[r6,#8]  ; Modify_C_READ
000356  1a89              SUBS     r1,r1,r2
;;;239    			var16a=var16a*2;
000358  0049              LSLS     r1,r1,#1
;;;240    			var32c=var32c/var16a;
00035a  fbb0f0f1          UDIV     r0,r0,r1
;;;241    			SET_LoadA = var32c;
00035e  f8c80008          STR      r0,[r8,#8]  ; Correct_Parametet
;;;242    			var32c = Modify_B_ACT;
000362  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;243    			var32c = var32c << 12;
000364  0300              LSLS     r0,r0,#12
;;;244    			var32d = SET_LoadA;
000366  f8d81008          LDR      r1,[r8,#8]  ; Correct_Parametet
;;;245    			var32d = var32d * (Modify_D_READ*2);
00036a  6972              LDR      r2,[r6,#0x14]  ; Modify_D_READ
00036c  4351              MULS     r1,r2,r1
00036e  0049              LSLS     r1,r1,#1
;;;246    			if (var32c < var32d)
000370  4288              CMP      r0,r1
000372  d206              BCS      |L3.898|
;;;247    			{
;;;248    				var32d = var32d - var32c;
000374  1a08              SUBS     r0,r1,r0
;;;249    				SET_LoadA_Offset = var32d;
000376  60a8              STR      r0,[r5,#8]  ; Correct_Strong
;;;250    				Polar1 |= 0x04;
000378  7860              LDRB     r0,[r4,#1]  ; correct_por
00037a  f0400004          ORR      r0,r0,#4
00037e  7060              STRB     r0,[r4,#1]
000380  e005              B        |L3.910|
                  |L3.898|
;;;251    			}
;;;252    			else 
;;;253    			{
;;;254    				var32c = var32c - var32d;
000382  1a40              SUBS     r0,r0,r1
;;;255    				SET_LoadA_Offset = var32c;
000384  60a8              STR      r0,[r5,#8]  ; Correct_Strong
;;;256    				Polar1 &= ~0x04;
000386  7860              LDRB     r0,[r4,#1]  ; correct_por
000388  f0200004          BIC      r0,r0,#4
00038c  7060              STRB     r0,[r4,#1]
                  |L3.910|
;;;257    			}
;;;258    			Flash_Write_all ();	
00038e  f7fffffe          BL       Flash_Write_all
;;;259    			Flag_DAC_OFF =0;
000392  6838              LDR      r0,[r7,#0]  ; flagB
000394  f0200008          BIC      r0,r0,#8
000398  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.922|
;;;260    		}
;;;261    /*************************************负载CV模式电压控制校准**************************************************************/
;;;262    		if(UART_Buffer_Rece[1] == 0x05)
00039a  4819              LDR      r0,|L3.1024|
00039c  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
00039e  2905              CMP      r1,#5
0003a0  d10a              BNE      |L3.952|
;;;263    		{
;;;264    			Modify_A_READ = Vmon1_value;//测量电压值
0003a2  f8db1000          LDR      r1,[r11,#0]  ; Vmon1_value
0003a6  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;265    			Modify_C_READ = Contr_Laod;//设置电压值
0003a8  f8ba1000          LDRH     r1,[r10,#0]  ; Contr_Laod
0003ac  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;266    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0003ae  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
0003b0  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
0003b2  eb012102          ADD      r1,r1,r2,LSL #8
0003b6  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.952|
;;;267    		}
;;;268    		if (UART_Buffer_Rece[1] == 0x06)			   //电压测量校准完成
0003b8  4811              LDR      r0,|L3.1024|
0003ba  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
0003bc  2806              CMP      r0,#6
0003be  d168              BNE      |L3.1170|
;;;269    		{
;;;270    			vu32 var16;
;;;271    			vu32 var32a;
;;;272    			vu32 var32b;
;;;273    			
;;;274    			vu32 var16a;
;;;275    			vu32 var32c;
;;;276    			vu32 var32d;
;;;277    			
;;;278    			Modify_B_READ =Vmon1_value;//测量电压值
0003c0  f8db0000          LDR      r0,[r11,#0]  ; Vmon1_value
0003c4  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;279    			Modify_D_READ =Contr_Laod;//设置电压值
0003c6  f8ba0000          LDRH     r0,[r10,#0]  ; Contr_Laod
0003ca  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;280    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
0003cc  480c              LDR      r0,|L3.1024|
0003ce  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
0003d0  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
0003d2  eb012000          ADD      r0,r1,r0,LSL #8
0003d6  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;281    			var32a = Modify_B_ACT;
0003d8  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;282    			var32a = var32a - Modify_A_ACT;
0003da  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0003dc  1a40              SUBS     r0,r0,r1
;;;283    			var32a = var32a << 12;
0003de  0301              LSLS     r1,r0,#12
;;;284    			var16 = Modify_B_READ - Modify_A_READ;
0003e0  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0003e2  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
0003e4  1a80              SUBS     r0,r0,r2
;;;285    			var32a = var32a / var16;
0003e6  fbb1f0f0          UDIV     r0,r1,r0
;;;286    			REG_LoadV = var32a;
0003ea  f8c8000c          STR      r0,[r8,#0xc]  ; Correct_Parametet
;;;287    			var32a=0;
;;;288    			var32a = Modify_B_ACT;
0003ee  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;289    			var32a = var32a << 12;
0003f0  0301              LSLS     r1,r0,#12
;;;290    			var32b = Modify_B_READ;
0003f2  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;291    			var32b = var32b * REG_LoadV;
0003f4  f8d8000c          LDR      r0,[r8,#0xc]  ; Correct_Parametet
0003f8  4350              MULS     r0,r2,r0
;;;292    			if (var32a < var32b)
0003fa  4281              CMP      r1,r0
0003fc  d21d              BCS      |L3.1082|
;;;293    			{
;;;294    				var32b = var32b - var32a;
0003fe  e015              B        |L3.1068|
                  |L3.1024|
                          DCD      UART_Buffer_Rece
                  |L3.1028|
                          DCD      ||area_number.8||
                  |L3.1032|
                          DCD      UART_Buffer_Send
                  |L3.1036|
                          DCD      Transmit_BUFFERsize
                  |L3.1040|
                          DCD      flagA
                  |L3.1044|
                          DCD      ||.bss||+0x58
                  |L3.1048|
                          DCD      flagF
                  |L3.1052|
                          DCD      Vmon1_value
                  |L3.1056|
                          DCD      flagB
                  |L3.1060|
                          DCD      Imon1_value
                  |L3.1064|
                          DCD      Contr_Laod
                  |L3.1068|
00042c  1a40              SUBS     r0,r0,r1
;;;295    				REG_LoadV_Offset = var32b;
00042e  60e8              STR      r0,[r5,#0xc]  ; Correct_Strong
;;;296    				Polar2 |= 0x01;
000430  78a0              LDRB     r0,[r4,#2]  ; correct_por
000432  f0400001          ORR      r0,r0,#1
000436  70a0              STRB     r0,[r4,#2]
000438  e005              B        |L3.1094|
                  |L3.1082|
;;;297    			}
;;;298    			else 
;;;299    			{
;;;300    				var32a = var32a - var32b;
00043a  1a08              SUBS     r0,r1,r0
;;;301    				REG_LoadV_Offset = var32a;
00043c  60e8              STR      r0,[r5,#0xc]  ; Correct_Strong
;;;302    				Polar2 &= ~0x01;
00043e  78a0              LDRB     r0,[r4,#2]  ; correct_por
000440  f0200001          BIC      r0,r0,#1
000444  70a0              STRB     r0,[r4,#2]
                  |L3.1094|
;;;303    			}
;;;304    //---------------------------------------------------------------------------------------//			
;;;305    			var32c = Modify_B_ACT; //CV模式电压控制校准
000446  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;306    			var32c = var32c - Modify_A_ACT;
000448  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00044a  1a40              SUBS     r0,r0,r1
;;;307    			var32c = var32c << 12;
00044c  0300              LSLS     r0,r0,#12
;;;308    			var16a=Modify_D_READ-Modify_C_READ;
00044e  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
000450  68b2              LDR      r2,[r6,#8]  ; Modify_C_READ
000452  1a89              SUBS     r1,r1,r2
;;;309    			var16a=(var16a*2);
000454  0049              LSLS     r1,r1,#1
;;;310    			var32c=var32c/var16a;
000456  fbb0f0f1          UDIV     r0,r0,r1
;;;311    			SET_LoadV = var32c;
00045a  f8c80010          STR      r0,[r8,#0x10]  ; Correct_Parametet
;;;312    			var32c = Modify_B_ACT;
00045e  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;313    			var32c = var32c << 12;
000460  0300              LSLS     r0,r0,#12
;;;314    			var32d = SET_LoadV;
000462  f8d81010          LDR      r1,[r8,#0x10]  ; Correct_Parametet
;;;315    			var32d = var32d * (Modify_D_READ*2);
000466  6972              LDR      r2,[r6,#0x14]  ; Modify_D_READ
000468  4351              MULS     r1,r2,r1
00046a  0049              LSLS     r1,r1,#1
;;;316    			if (var32c < var32d)
00046c  4288              CMP      r0,r1
00046e  d206              BCS      |L3.1150|
;;;317    			{
;;;318    				var32d = var32d - var32c;
000470  1a08              SUBS     r0,r1,r0
;;;319    				SET_LoadV_Offset = var32d;
000472  6128              STR      r0,[r5,#0x10]  ; Correct_Strong
;;;320    				Polar2 |= 0x04;
000474  78a0              LDRB     r0,[r4,#2]  ; correct_por
000476  f0400004          ORR      r0,r0,#4
00047a  70a0              STRB     r0,[r4,#2]
00047c  e005              B        |L3.1162|
                  |L3.1150|
;;;321    			}
;;;322    			else 
;;;323    			{
;;;324    				var32c = var32c - var32d;
00047e  1a40              SUBS     r0,r0,r1
;;;325    				SET_LoadV_Offset = var32c;
000480  6128              STR      r0,[r5,#0x10]  ; Correct_Strong
;;;326    				Polar2 &= ~0x04;
000482  78a0              LDRB     r0,[r4,#2]  ; correct_por
000484  f0200004          BIC      r0,r0,#4
000488  70a0              STRB     r0,[r4,#2]
                  |L3.1162|
;;;327    			}
;;;328    //---------------------------------------------------------------------------------------//
;;;329    		  Flash_Write_all();	//参数写进FLASH
00048a  f7fffffe          BL       Flash_Write_all
;;;330    			DAC_Flag=0;
00048e  2000              MOVS     r0,#0
000490  7030              STRB     r0,[r6,#0]
                  |L3.1170|
;;;331    		}
;;;332    /*************************************内阻校准**************************************************************************/
;;;333    		if(UART_Buffer_Rece[1] == 0x07||flag_ADJ_VL==1)
000492  f8dfb368          LDR      r11,|L3.2044|
000496  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
;;;334    		{
;;;335    			Modify_A_READ = Rmon_value;//测量电压值
00049a  48d9              LDR      r0,|L3.2048|
00049c  2907              CMP      r1,#7                 ;333
00049e  d003              BEQ      |L3.1192|
0004a0  f8d91000          LDR      r1,[r9,#0]            ;333  ; flagF
0004a4  0749              LSLS     r1,r1,#29             ;333
0004a6  d508              BPL      |L3.1210|
                  |L3.1192|
0004a8  8801              LDRH     r1,[r0,#0]  ; Rmon_value
0004aa  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;336    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0004ac  f89b1004          LDRB     r1,[r11,#4]  ; UART_Buffer_Rece
0004b0  f89b2003          LDRB     r2,[r11,#3]  ; UART_Buffer_Rece
0004b4  eb012102          ADD      r1,r1,r2,LSL #8
0004b8  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1210|
;;;337    		}
;;;338    		if (UART_Buffer_Rece[1] == 0x08||flag_ADJ_VH==1)			   //电压测量校准完成
0004ba  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
0004be  2908              CMP      r1,#8
0004c0  d003              BEQ      |L3.1226|
0004c2  f8d91000          LDR      r1,[r9,#0]  ; flagF
0004c6  0709              LSLS     r1,r1,#28
0004c8  d541              BPL      |L3.1358|
                  |L3.1226|
;;;339    		{
;;;340    			vu16 var16;
;;;341    			vu32 var32a;
;;;342    			vu32 var32b;
;;;343    			
;;;344    			vu16 var16a;
;;;345    			vu32 var32c;
;;;346    			vu32 var32d;
;;;347    			Modify_B_READ =Rmon_value;//测量电压值
0004ca  8800              LDRH     r0,[r0,#0]  ; Rmon_value
0004cc  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;348    			flag_OverV=1;
0004ce  49cd              LDR      r1,|L3.2052|
0004d0  6808              LDR      r0,[r1,#0]  ; flagG
0004d2  f0400002          ORR      r0,r0,#2
0004d6  6008              STR      r0,[r1,#0]  ; flagG
;;;349    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
0004d8  f89b1004          LDRB     r1,[r11,#4]  ; UART_Buffer_Rece
0004dc  f89b2003          LDRB     r2,[r11,#3]  ; UART_Buffer_Rece
0004e0  eb012102          ADD      r1,r1,r2,LSL #8
0004e4  61b1              STR      r1,[r6,#0x18]  ; Modify_B_ACT
;;;350    			if(flag_OverV==1)//只有当有数据写入时才能将校准数据写入FLASH
0004e6  0780              LSLS     r0,r0,#30
0004e8  d52b              BPL      |L3.1346|
;;;351    			{
;;;352    				var32a = Modify_B_ACT;
0004ea  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;353    				var32a = var32a - Modify_A_ACT;
0004ec  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0004ee  1a40              SUBS     r0,r0,r1
;;;354    				var32a = var32a << 12;
0004f0  0301              LSLS     r1,r0,#12
;;;355    				var16 = Modify_B_READ - Modify_A_READ;
0004f2  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0004f4  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
0004f6  1a80              SUBS     r0,r0,r2
0004f8  b280              UXTH     r0,r0
;;;356    				var32a = var32a / var16;
0004fa  fbb1f0f0          UDIV     r0,r1,r0
;;;357    				REG_CorrectionR = var32a;
0004fe  f8c80014          STR      r0,[r8,#0x14]  ; Correct_Parametet
;;;358    				var32a=0;
;;;359    				var32a = Modify_B_ACT;
000502  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;360    				var32a = var32a << 12;
000504  0301              LSLS     r1,r0,#12
;;;361    				var32b = Modify_B_READ;
000506  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;362    				var32b = var32b * REG_CorrectionR;
000508  f8d80014          LDR      r0,[r8,#0x14]  ; Correct_Parametet
00050c  4350              MULS     r0,r2,r0
;;;363    				if (var32a < var32b)
00050e  4281              CMP      r1,r0
000510  d206              BCS      |L3.1312|
;;;364    				{
;;;365    					var32b = var32b - var32a;
000512  1a40              SUBS     r0,r0,r1
;;;366    					REG_ReadR_Offset = var32b;
000514  6168              STR      r0,[r5,#0x14]  ; Correct_Strong
;;;367    					Polar3 |= 0x01;
000516  78e0              LDRB     r0,[r4,#3]  ; correct_por
000518  f0400001          ORR      r0,r0,#1
00051c  70e0              STRB     r0,[r4,#3]
00051e  e005              B        |L3.1324|
                  |L3.1312|
;;;368    				}
;;;369    				else 
;;;370    				{
;;;371    					var32a = var32a - var32b;
000520  1a08              SUBS     r0,r1,r0
;;;372    					REG_ReadR_Offset = var32a;
000522  6168              STR      r0,[r5,#0x14]  ; Correct_Strong
;;;373    					Polar3 &= ~0x01;
000524  78e0              LDRB     r0,[r4,#3]  ; correct_por
000526  f0200001          BIC      r0,r0,#1
00052a  70e0              STRB     r0,[r4,#3]
                  |L3.1324|
;;;374    				}
;;;375    	//---------------------------------------------------------------------------------------//
;;;376    				Flash_Write_all();	//参数写进FLASH
00052c  f7fffffe          BL       Flash_Write_all
;;;377    				flag_OverV=0;
000530  48b4              LDR      r0,|L3.2052|
000532  6801              LDR      r1,[r0,#0]  ; flagG
000534  f0210102          BIC      r1,r1,#2
000538  6001              STR      r1,[r0,#0]  ; flagG
;;;378    				Flag_DAC_OFF=0;
00053a  6838              LDR      r0,[r7,#0]  ; flagB
00053c  f0200008          BIC      r0,r0,#8
000540  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1346|
;;;379    			}
;;;380    			flag_ADJ_VH=0;//清掉标志位防止一直进入
000542  f8d90000          LDR      r0,[r9,#0]  ; flagF
000546  f0200008          BIC      r0,r0,#8
00054a  f8c90000          STR      r0,[r9,#0]  ; flagF
                  |L3.1358|
;;;381    		}		
;;;382    /*******************************电源CC模式电流测量和控制校准******************************************/	
;;;383    		if (UART_Buffer_Rece[1] == 0x09||flag_ADJ_ALCC==1)			   //电流测量校准
00054e  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
000552  4658              MOV      r0,r11
;;;384    		{
;;;385    			Modify_A_READ = Imon_value;//测量电流
000554  f8dfb2b0          LDR      r11,|L3.2056|
000558  2909              CMP      r1,#9                 ;383
00055a  d003              BEQ      |L3.1380|
00055c  f8d91000          LDR      r1,[r9,#0]            ;383  ; flagF
000560  06c9              LSLS     r1,r1,#27             ;383
000562  d50a              BPL      |L3.1402|
                  |L3.1380|
000564  f8bb1000          LDRH     r1,[r11,#0]  ; Imon_value
000568  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;386    			Modify_C_READ = Contr_Current;//设置电流
00056a  49a8              LDR      r1,|L3.2060|
00056c  8809              LDRH     r1,[r1,#0]  ; Contr_Current
00056e  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;387    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000570  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000572  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000574  eb012102          ADD      r1,r1,r2,LSL #8
000578  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1402|
;;;388    		}
;;;389    
;;;390    		if (UART_Buffer_Rece[1] == 0x0A||flag_ADJ_AHCC==1)			   //电流测量校准完成
00057a  48a0              LDR      r0,|L3.2044|
00057c  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
00057e  280a              CMP      r0,#0xa
000580  d003              BEQ      |L3.1418|
000582  f8d90000          LDR      r0,[r9,#0]  ; flagF
000586  0680              LSLS     r0,r0,#26
000588  d555              BPL      |L3.1590|
                  |L3.1418|
;;;391    		{
;;;392    			vu16 var16;
;;;393    			vu32 var32a;
;;;394    			vu32 var32b;
;;;395    			
;;;396    			vu16 var16a;
;;;397    			vu32 var32c;
;;;398    			vu32 var32d;
;;;399    			
;;;400    			Modify_D_READ = Contr_Current;
00058a  48a0              LDR      r0,|L3.2060|
00058c  8800              LDRH     r0,[r0,#0]  ; Contr_Current
00058e  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;401    			Modify_B_READ = Imon_value;
000590  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
000594  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;402    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000596  4899              LDR      r0,|L3.2044|
000598  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
00059a  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
00059c  eb012000          ADD      r0,r1,r0,LSL #8
0005a0  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;403    			var32a = Modify_B_ACT;
0005a2  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;404    			var32a = var32a - Modify_A_ACT;
0005a4  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0005a6  1a40              SUBS     r0,r0,r1
;;;405    			var32a = var32a << 14;
0005a8  0381              LSLS     r1,r0,#14
;;;406    			var16 = Modify_B_READ - Modify_A_READ;
0005aa  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0005ac  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
0005ae  1a80              SUBS     r0,r0,r2
0005b0  b280              UXTH     r0,r0
;;;407    			var32a = var32a / var16;
0005b2  fbb1f0f0          UDIV     r0,r1,r0
;;;408    			REG_POWERA = var32a;
0005b6  f8c80018          STR      r0,[r8,#0x18]  ; Correct_Parametet
;;;409    			var32a = Modify_B_ACT;
0005ba  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;410    			var32a = var32a << 14;
0005bc  0381              LSLS     r1,r0,#14
;;;411    			var32b = Modify_B_READ;
0005be  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;412    			var32b = var32b * REG_POWERA;
0005c0  f8d80018          LDR      r0,[r8,#0x18]  ; Correct_Parametet
0005c4  4350              MULS     r0,r2,r0
;;;413    			if (var32a < var32b)
0005c6  4281              CMP      r1,r0
0005c8  d206              BCS      |L3.1496|
;;;414    			{
;;;415    				var32b = var32b - var32a;
0005ca  1a40              SUBS     r0,r0,r1
;;;416    				REG_POWERA_Offset = var32b;
0005cc  61a8              STR      r0,[r5,#0x18]  ; Correct_Strong
;;;417    				Polar4 |= 0x01;
0005ce  7920              LDRB     r0,[r4,#4]  ; correct_por
0005d0  f0400001          ORR      r0,r0,#1
0005d4  7120              STRB     r0,[r4,#4]
0005d6  e005              B        |L3.1508|
                  |L3.1496|
;;;418    			}
;;;419    			else 
;;;420    			{
;;;421    				var32a = var32a - var32b;
0005d8  1a08              SUBS     r0,r1,r0
;;;422    				REG_POWERA_Offset = var32a;
0005da  61a8              STR      r0,[r5,#0x18]  ; Correct_Strong
;;;423    				Polar4 &= ~0x01;					//电流测量系数和零点校准完成
0005dc  7920              LDRB     r0,[r4,#4]  ; correct_por
0005de  f0200001          BIC      r0,r0,#1
0005e2  7120              STRB     r0,[r4,#4]
                  |L3.1508|
;;;424    			}
;;;425    	//---------------------------------------------------------------------------------//
;;;426    			var32c = Modify_B_ACT; //设置电流校准
0005e4  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;427    			var32c = var32c - Modify_A_ACT;
0005e6  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0005e8  1a40              SUBS     r0,r0,r1
;;;428    			var32c = var32c << 14;
0005ea  0381              LSLS     r1,r0,#14
;;;429    			var16a=Modify_D_READ-Modify_C_READ;
0005ec  6970              LDR      r0,[r6,#0x14]  ; Modify_D_READ
0005ee  68b2              LDR      r2,[r6,#8]  ; Modify_C_READ
0005f0  1a80              SUBS     r0,r0,r2
;;;430    			var16a=var16a*2;
0005f2  0440              LSLS     r0,r0,#17
0005f4  0c00              LSRS     r0,r0,#16
;;;431    			var32c=var32c/var16a;
0005f6  fbb1f0f0          UDIV     r0,r1,r0
;;;432    			SET_POWERA = var32c;
0005fa  f8c8001c          STR      r0,[r8,#0x1c]  ; Correct_Parametet
;;;433    			var32c = Modify_B_ACT;
0005fe  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;434    			var32c = var32c << 14;
000600  0380              LSLS     r0,r0,#14
;;;435    			var32d = SET_POWERA;
000602  f8d8101c          LDR      r1,[r8,#0x1c]  ; Correct_Parametet
;;;436    			var32d = var32d * (Modify_D_READ*2);
000606  6972              LDR      r2,[r6,#0x14]  ; Modify_D_READ
000608  4351              MULS     r1,r2,r1
00060a  0049              LSLS     r1,r1,#1
;;;437    			if (var32c < var32d)
00060c  4288              CMP      r0,r1
00060e  d206              BCS      |L3.1566|
;;;438    			{
;;;439    				var32d = var32d - var32c;
000610  1a08              SUBS     r0,r1,r0
;;;440    				SET_POWERA_Offset = var32d;
000612  61e8              STR      r0,[r5,#0x1c]  ; Correct_Strong
;;;441    				Polar4 |= 0x04;
000614  7920              LDRB     r0,[r4,#4]  ; correct_por
000616  f0400004          ORR      r0,r0,#4
00061a  7120              STRB     r0,[r4,#4]
00061c  e005              B        |L3.1578|
                  |L3.1566|
;;;442    			}
;;;443    			else 
;;;444    			{
;;;445    				var32c = var32c - var32d;
00061e  1a40              SUBS     r0,r0,r1
;;;446    				SET_POWERA_Offset = var32c;
000620  61e8              STR      r0,[r5,#0x1c]  ; Correct_Strong
;;;447    				Polar4 &= ~0x04;
000622  7920              LDRB     r0,[r4,#4]  ; correct_por
000624  f0200004          BIC      r0,r0,#4
000628  7120              STRB     r0,[r4,#4]
                  |L3.1578|
;;;448    			}
;;;449    			Flash_Write_all ();	
00062a  f7fffffe          BL       Flash_Write_all
;;;450    			Flag_DAC_OFF=0;
00062e  6838              LDR      r0,[r7,#0]  ; flagB
000630  f0200008          BIC      r0,r0,#8
000634  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1590|
;;;451    		}
;;;452    /*******************************电源电压控制和测量校准******************************************/	
;;;453    		if (UART_Buffer_Rece[1] == 0x0B)			   //电流测量校准
000636  f8df91c4          LDR      r9,|L3.2044|
00063a  f8991001          LDRB     r1,[r9,#1]  ; UART_Buffer_Rece
;;;454    		{
;;;455    			Modify_A_READ = Vmon_value;//测量电流
00063e  4874              LDR      r0,|L3.2064|
000640  290b              CMP      r1,#0xb               ;453
000642  d10b              BNE      |L3.1628|
000644  8801              LDRH     r1,[r0,#0]  ; Vmon_value
000646  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;456    			Modify_C_READ = Contr_Voltage;//设置电流
000648  4972              LDR      r1,|L3.2068|
00064a  8809              LDRH     r1,[r1,#0]  ; Contr_Voltage
00064c  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;457    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00064e  f8991004          LDRB     r1,[r9,#4]  ; UART_Buffer_Rece
000652  f8992003          LDRB     r2,[r9,#3]  ; UART_Buffer_Rece
000656  eb012102          ADD      r1,r1,r2,LSL #8
00065a  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1628|
;;;458    		}
;;;459    
;;;460    		if (UART_Buffer_Rece[1] == 0x0C)			   //电流测量校准完成
00065c  f8991001          LDRB     r1,[r9,#1]  ; UART_Buffer_Rece
000660  290c              CMP      r1,#0xc
000662  d155              BNE      |L3.1808|
;;;461    		{
;;;462    			vu16 var16;
;;;463    			vu32 var32a;
;;;464    			vu32 var32b;
;;;465    			
;;;466    			vu16 var16a;
;;;467    			vu32 var32c;
;;;468    			vu32 var32d;
;;;469    			
;;;470    			Modify_D_READ = Contr_Voltage;
000664  496b              LDR      r1,|L3.2068|
000666  8809              LDRH     r1,[r1,#0]  ; Contr_Voltage
000668  6171              STR      r1,[r6,#0x14]  ; Modify_D_READ
;;;471    			Modify_B_READ = Vmon_value;
00066a  8800              LDRH     r0,[r0,#0]  ; Vmon_value
00066c  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;472    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00066e  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000672  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000676  eb002001          ADD      r0,r0,r1,LSL #8
00067a  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;473    			var32a = Modify_B_ACT;
00067c  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;474    			var32a = var32a - Modify_A_ACT;
00067e  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
000680  1a40              SUBS     r0,r0,r1
;;;475    			var32a = var32a << 14;
000682  0381              LSLS     r1,r0,#14
;;;476    			var16 = Modify_B_READ - Modify_A_READ;
000684  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000686  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
000688  1a80              SUBS     r0,r0,r2
00068a  b280              UXTH     r0,r0
;;;477    			var32a = var32a / var16;
00068c  fbb1f0f0          UDIV     r0,r1,r0
;;;478    			REG_POWERV = var32a;
000690  f8c80020          STR      r0,[r8,#0x20]  ; Correct_Parametet
;;;479    			var32a = Modify_B_ACT;
000694  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;480    			var32a = var32a << 14;
000696  0381              LSLS     r1,r0,#14
;;;481    			var32b = Modify_B_READ;
000698  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;482    			var32b = var32b * REG_POWERV;
00069a  f8d80020          LDR      r0,[r8,#0x20]  ; Correct_Parametet
00069e  4350              MULS     r0,r2,r0
;;;483    			if (var32a < var32b)
0006a0  4281              CMP      r1,r0
0006a2  d206              BCS      |L3.1714|
;;;484    			{
;;;485    				var32b = var32b - var32a;
0006a4  1a40              SUBS     r0,r0,r1
;;;486    				REG_POWERV_Offset = var32b;
0006a6  6228              STR      r0,[r5,#0x20]  ; Correct_Strong
;;;487    				Polar5 |= 0x01;
0006a8  7960              LDRB     r0,[r4,#5]  ; correct_por
0006aa  f0400001          ORR      r0,r0,#1
0006ae  7160              STRB     r0,[r4,#5]
0006b0  e005              B        |L3.1726|
                  |L3.1714|
;;;488    			}
;;;489    			else 
;;;490    			{
;;;491    				var32a = var32a - var32b;
0006b2  1a08              SUBS     r0,r1,r0
;;;492    				REG_POWERV_Offset = var32a;
0006b4  6228              STR      r0,[r5,#0x20]  ; Correct_Strong
;;;493    				Polar5 &= ~0x01;					
0006b6  7960              LDRB     r0,[r4,#5]  ; correct_por
0006b8  f0200001          BIC      r0,r0,#1
0006bc  7160              STRB     r0,[r4,#5]
                  |L3.1726|
;;;494    			}
;;;495    	//---------------------------------------------------------------------------------//
;;;496    			var32c = Modify_B_ACT; //设置电压校准
0006be  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;497    			var32c = var32c - Modify_A_ACT;
0006c0  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0006c2  1a40              SUBS     r0,r0,r1
;;;498    			var32c = var32c << 14;
0006c4  0381              LSLS     r1,r0,#14
;;;499    			var16a=Modify_D_READ-Modify_C_READ;
0006c6  6970              LDR      r0,[r6,#0x14]  ; Modify_D_READ
0006c8  68b2              LDR      r2,[r6,#8]  ; Modify_C_READ
0006ca  1a80              SUBS     r0,r0,r2
;;;500    			var16a=var16a*2;
0006cc  0440              LSLS     r0,r0,#17
0006ce  0c00              LSRS     r0,r0,#16
;;;501    			var32c=var32c/var16a;
0006d0  fbb1f0f0          UDIV     r0,r1,r0
;;;502    			SET_POWERV = var32c;
0006d4  f8c80024          STR      r0,[r8,#0x24]  ; Correct_Parametet
;;;503    			var32c = Modify_B_ACT;
0006d8  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;504    			var32c = var32c << 14;
0006da  0380              LSLS     r0,r0,#14
;;;505    			var32d = SET_POWERV;
0006dc  f8d81024          LDR      r1,[r8,#0x24]  ; Correct_Parametet
;;;506    			var32d = var32d * (Modify_D_READ*2);
0006e0  6972              LDR      r2,[r6,#0x14]  ; Modify_D_READ
0006e2  4351              MULS     r1,r2,r1
0006e4  0049              LSLS     r1,r1,#1
;;;507    			if (var32c < var32d)
0006e6  4288              CMP      r0,r1
0006e8  d206              BCS      |L3.1784|
;;;508    			{
;;;509    				var32d = var32d - var32c;
0006ea  1a08              SUBS     r0,r1,r0
;;;510    				SET_POWERV_Offset = var32d;
0006ec  6268              STR      r0,[r5,#0x24]  ; Correct_Strong
;;;511    				Polar5 |= 0x04;
0006ee  7960              LDRB     r0,[r4,#5]  ; correct_por
0006f0  f0400004          ORR      r0,r0,#4
0006f4  7160              STRB     r0,[r4,#5]
0006f6  e005              B        |L3.1796|
                  |L3.1784|
;;;512    			}
;;;513    			else 
;;;514    			{
;;;515    				var32c = var32c - var32d;
0006f8  1a40              SUBS     r0,r0,r1
;;;516    				SET_POWERV_Offset = var32c;
0006fa  6268              STR      r0,[r5,#0x24]  ; Correct_Strong
;;;517    				Polar5 &= ~0x04;
0006fc  7960              LDRB     r0,[r4,#5]  ; correct_por
0006fe  f0200004          BIC      r0,r0,#4
000702  7160              STRB     r0,[r4,#5]
                  |L3.1796|
;;;518    			}
;;;519    			Flash_Write_all ();	
000704  f7fffffe          BL       Flash_Write_all
;;;520    			Flag_DAC_OFF=0;
000708  6838              LDR      r0,[r7,#0]  ; flagB
00070a  f0200008          BIC      r0,r0,#8
00070e  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1808|
;;;521    		}
;;;522    /****************电源电流测量校准**********************************/
;;;523    		if (UART_Buffer_Rece[1] == 0x0D)			  
000710  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000714  280d              CMP      r0,#0xd
000716  d109              BNE      |L3.1836|
;;;524    		{ 
;;;525    			Modify_A_READ = Imon_value;
000718  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
00071c  6070              STR      r0,[r6,#4]  ; Modify_A_READ
;;;526    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00071e  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000722  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000726  eb002001          ADD      r0,r0,r1,LSL #8
00072a  60f0              STR      r0,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1836|
;;;527    		}
;;;528    
;;;529    		if (UART_Buffer_Rece[1] == 0x0E)			   
00072c  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000730  280e              CMP      r0,#0xe
000732  d130              BNE      |L3.1942|
;;;530    		{
;;;531    			vu16 var16;
;;;532    			vu32 var32a;
;;;533    			vu32 var32b;
;;;534    			
;;;535    			vu16 var16a;
;;;536    			vu32 var32c;
;;;537    			vu32 var32d;
;;;538    			
;;;539    			Modify_B_READ = Imon_value;
000734  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
000738  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;540    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00073a  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
00073e  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000742  eb002001          ADD      r0,r0,r1,LSL #8
000746  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;541    			var32a = Modify_B_ACT;
000748  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;542    			var32a = var32a - Modify_A_ACT;
00074a  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00074c  1a40              SUBS     r0,r0,r1
;;;543    			var32a = var32a << 14;
00074e  0381              LSLS     r1,r0,#14
;;;544    			var16 = Modify_B_READ - Modify_A_READ;
000750  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000752  6872              LDR      r2,[r6,#4]  ; Modify_A_READ
000754  1a80              SUBS     r0,r0,r2
000756  b280              UXTH     r0,r0
;;;545    			var32a = var32a / var16;
000758  fbb1f0f0          UDIV     r0,r1,r0
;;;546    			CON_POWERA = var32a;
00075c  f8c80028          STR      r0,[r8,#0x28]  ; Correct_Parametet
;;;547    			var32a = Modify_B_ACT;
000760  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;548    			var32a = var32a << 14;
000762  0381              LSLS     r1,r0,#14
;;;549    			var32b = Modify_B_READ;
000764  6932              LDR      r2,[r6,#0x10]  ; Modify_B_READ
;;;550    			var32b = var32b * CON_POWERA;
000766  f8d80028          LDR      r0,[r8,#0x28]  ; Correct_Parametet
00076a  4350              MULS     r0,r2,r0
;;;551    			if (var32a < var32b)
00076c  4281              CMP      r1,r0
00076e  d206              BCS      |L3.1918|
;;;552    			{
;;;553    				var32b = var32b - var32a;
000770  1a40              SUBS     r0,r0,r1
;;;554    				CON_POWERA_Offset = var32b;
000772  62a8              STR      r0,[r5,#0x28]  ; Correct_Strong
;;;555    				Polar3 |= 0x04;
000774  78e0              LDRB     r0,[r4,#3]  ; correct_por
000776  f0400004          ORR      r0,r0,#4
00077a  70e0              STRB     r0,[r4,#3]
00077c  e005              B        |L3.1930|
                  |L3.1918|
;;;556    			}
;;;557    			else 
;;;558    			{
;;;559    				var32a = var32a - var32b;
00077e  1a08              SUBS     r0,r1,r0
;;;560    				CON_POWERA_Offset = var32a;
000780  62a8              STR      r0,[r5,#0x28]  ; Correct_Strong
;;;561    				Polar3 &= ~0x04;					
000782  78e0              LDRB     r0,[r4,#3]  ; correct_por
000784  f0200004          BIC      r0,r0,#4
000788  70e0              STRB     r0,[r4,#3]
                  |L3.1930|
;;;562    			}
;;;563    			Flash_Write_all ();	
00078a  f7fffffe          BL       Flash_Write_all
;;;564    			Flag_DAC_OFF=0;
00078e  6838              LDR      r0,[r7,#0]  ; flagB
000790  f0200008          BIC      r0,r0,#8
000794  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1942|
;;;565    		}
;;;566    /***********接受DAC*******************************************/
;;;567    		if (UART_Buffer_Rece[1] == 0x0F)			   
000796  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
00079a  280f              CMP      r0,#0xf
00079c  d10b              BNE      |L3.1974|
;;;568    		{
;;;569    			Contr_Laod = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
00079e  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
0007a2  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
0007a6  eb002001          ADD      r0,r0,r1,LSL #8
0007aa  f8aa0000          STRH     r0,[r10,#0]
;;;570    			Flag_DAC_OFF=1;
0007ae  6838              LDR      r0,[r7,#0]  ; flagB
0007b0  f0400008          ORR      r0,r0,#8
0007b4  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1974|
;;;571    		}
;;;572    		if (UART_Buffer_Rece[1] == 0x20)			   
0007b6  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
0007ba  2820              CMP      r0,#0x20
0007bc  d10b              BNE      |L3.2006|
;;;573    		{
;;;574    			Contr_Voltage = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0007be  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
0007c2  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
0007c6  eb002101          ADD      r1,r0,r1,LSL #8
0007ca  4812              LDR      r0,|L3.2068|
0007cc  8001              STRH     r1,[r0,#0]
;;;575    			Flag_DAC_OFF=1;
0007ce  6838              LDR      r0,[r7,#0]  ; flagB
0007d0  f0400008          ORR      r0,r0,#8
0007d4  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2006|
;;;576    		}
;;;577    		if (UART_Buffer_Rece[1] == 0x21)			   
0007d6  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
0007da  2821              CMP      r0,#0x21
0007dc  d10b              BNE      |L3.2038|
;;;578    		{
;;;579    			Contr_Current = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0007de  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
0007e2  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
0007e6  eb002101          ADD      r1,r0,r1,LSL #8
0007ea  4808              LDR      r0,|L3.2060|
0007ec  8001              STRH     r1,[r0,#0]
;;;580    			Flag_DAC_OFF=1;
0007ee  6838              LDR      r0,[r7,#0]  ; flagB
0007f0  f0400008          ORR      r0,r0,#8
0007f4  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2038|
;;;581    		}
;;;582    	}
;;;583    //===================================================================================
;;;584    }
0007f6  e8bd9ff0          POP      {r4-r12,pc}
;;;585    //===============================AD值转换成测量值============================================//
                          ENDP

0007fa  0000              DCW      0x0000
                  |L3.2044|
                          DCD      UART_Buffer_Rece
                  |L3.2048|
                          DCD      Rmon_value
                  |L3.2052|
                          DCD      flagG
                  |L3.2056|
                          DCD      Imon_value
                  |L3.2060|
                          DCD      Contr_Current
                  |L3.2064|
                          DCD      Vmon_value
                  |L3.2068|
                          DCD      Contr_Voltage

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        44
                  Correct_Strong
                          %        44
                  Run_Control
                          %        56

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00
                  ADDR
000001  000000            DCB      0x00,0x00,0x00
                  Modify_A_READ
                          DCD      0x00000000
                  Modify_C_READ
                          DCD      0x00000000
                  Modify_A_ACT
                          DCD      0x00000000
                  Modify_B_READ
                          DCD      0x00000000
                  Modify_D_READ
                          DCD      0x00000000
                  Modify_B_ACT
                          DCD      0x00000000
                  correct_por
                          DCD      0x00000000
000020  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 128
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
