; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\output\modbus.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\modbus.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\output\modbus.crf ..\drive\modbus.c]
                          THUMB

                          AREA ||i.Hardware_CRC||, CODE, READONLY, ALIGN=1

                  Hardware_CRC PROC
;;;786    //-----------------------------CRC检测--------------------------------------------//
;;;787    vu16 Hardware_CRC(vu8 *p_buffer,vu8 count)    //CRC16
000000  b503              PUSH     {r0,r1,lr}
;;;788    {
000002  b082              SUB      sp,sp,#8
;;;789    	vu16 CRC_Result=0xffff;
000004  f64f71ff          MOV      r1,#0xffff
000008  9101              STR      r1,[sp,#4]
;;;790    	vu8 i;
;;;791    	if(count==0)
00000a  f89d100c          LDRB     r1,[sp,#0xc]
00000e  2900              CMP      r1,#0
000010  d126              BNE      |L1.96|
;;;792    	{
;;;793    		count=1;
000012  2101              MOVS     r1,#1
000014  9103              STR      r1,[sp,#0xc]
000016  e023              B        |L1.96|
                  |L1.24|
;;;794    	}
;;;795    	while(count--)
;;;796    	{
;;;797    		CRC_Result^=*p_buffer;
000018  7801              LDRB     r1,[r0,#0]
00001a  f8bd2004          LDRH     r2,[sp,#4]
00001e  4051              EORS     r1,r1,r2
000020  9101              STR      r1,[sp,#4]
;;;798    		for(i=0;i<8;i++)
000022  2100              MOVS     r1,#0
000024  9100              STR      r1,[sp,#0]
;;;799    		{
;;;800    			if(CRC_Result&1)
;;;801    			{
;;;802    				CRC_Result>>=1;
;;;803    				CRC_Result^=0xA001;
000026  f24a0201          MOV      r2,#0xa001
00002a  e014              B        |L1.86|
                  |L1.44|
00002c  f8bd1004          LDRH     r1,[sp,#4]            ;800
000030  07c9              LSLS     r1,r1,#31             ;800
000032  d008              BEQ      |L1.70|
000034  f8bd1004          LDRH     r1,[sp,#4]            ;802
000038  0849              LSRS     r1,r1,#1              ;802
00003a  9101              STR      r1,[sp,#4]            ;802
00003c  f8bd1004          LDRH     r1,[sp,#4]
000040  4051              EORS     r1,r1,r2
000042  9101              STR      r1,[sp,#4]
000044  e003              B        |L1.78|
                  |L1.70|
;;;804    			}
;;;805    			else 
;;;806    			{
;;;807    				CRC_Result>>=1;
000046  f8bd1004          LDRH     r1,[sp,#4]
00004a  0849              LSRS     r1,r1,#1
00004c  9101              STR      r1,[sp,#4]
                  |L1.78|
00004e  f89d1000          LDRB     r1,[sp,#0]            ;798
000052  1c49              ADDS     r1,r1,#1              ;798
000054  9100              STR      r1,[sp,#0]            ;798
                  |L1.86|
000056  f89d1000          LDRB     r1,[sp,#0]            ;798
00005a  2908              CMP      r1,#8                 ;798
00005c  d3e6              BCC      |L1.44|
;;;808    			}
;;;809    		}
;;;810    		p_buffer++;
00005e  1c40              ADDS     r0,r0,#1
                  |L1.96|
000060  f89d100c          LDRB     r1,[sp,#0xc]          ;795
000064  1e4a              SUBS     r2,r1,#1              ;795
000066  9203              STR      r2,[sp,#0xc]          ;795
000068  2900              CMP      r1,#0                 ;795
00006a  d1d5              BNE      |L1.24|
;;;811    	}
;;;812    	return CRC_Result;
00006c  f8bd0004          LDRH     r0,[sp,#4]
;;;813    }
000070  b004              ADD      sp,sp,#0x10
000072  bd00              POP      {pc}
                          ENDP


                          AREA ||i.Transformation_ADC||, CODE, READONLY, ALIGN=2

                  Transformation_ADC PROC
;;;585    //===============================AD值转换成测量值============================================//
;;;586    void Transformation_ADC(void)  
000000  b5f8              PUSH     {r3-r7,lr}
;;;587    {
;;;588    	vu32 var32;
;;;589    	vu32 var32a;
;;;590    /*****************************内阻测量电压转换*******************************************/
;;;591    	var32 = Vmon1_value;
000002  48d4              LDR      r0,|L2.852|
000004  6800              LDR      r0,[r0,#0]  ; Vmon1_value
000006  9000              STR      r0,[sp,#0]
;;;592    	var32 = var32 * REG_CorrectionV;  
000008  4dd3              LDR      r5,|L2.856|
00000a  6828              LDR      r0,[r5,#0]  ; Correct_Parametet
00000c  9900              LDR      r1,[sp,#0]
00000e  4348              MULS     r0,r1,r0
000010  9000              STR      r0,[sp,#0]
;;;593    	if ((Polar & 0x01) == 0x01)		  
000012  4cd2              LDR      r4,|L2.860|
000014  7820              LDRB     r0,[r4,#0]  ; correct_por
;;;594    	{
;;;595    		if (var32 < REG_ReadV_Offset) 
000016  f04f0100          MOV      r1,#0
00001a  07c2              LSLS     r2,r0,#31             ;593
00001c  f105002c          ADD      r0,r5,#0x2c
000020  d00a              BEQ      |L2.56|
000022  6802              LDR      r2,[r0,#0]  ; Correct_Strong
000024  9b00              LDR      r3,[sp,#0]
000026  429a              CMP      r2,r3
000028  d901              BLS      |L2.46|
;;;596    		{
;;;597    			var32 = 0;
00002a  9100              STR      r1,[sp,#0]
00002c  e008              B        |L2.64|
                  |L2.46|
;;;598    		}
;;;599    		else var32 = var32 - REG_ReadV_Offset;
00002e  6802              LDR      r2,[r0,#0]  ; Correct_Strong
000030  9b00              LDR      r3,[sp,#0]
000032  1a9a              SUBS     r2,r3,r2
000034  9200              STR      r2,[sp,#0]
000036  e003              B        |L2.64|
                  |L2.56|
;;;600    	}
;;;601    	else var32 = var32 + REG_ReadV_Offset;
000038  6802              LDR      r2,[r0,#0]  ; Correct_Strong
00003a  9b00              LDR      r3,[sp,#0]
00003c  441a              ADD      r2,r2,r3
00003e  9200              STR      r2,[sp,#0]
                  |L2.64|
;;;602    	var32 = var32 >> 12;
000040  9a00              LDR      r2,[sp,#0]
000042  0b12              LSRS     r2,r2,#12
000044  9200              STR      r2,[sp,#0]
;;;603    	if (var32 < 30) var32 = 0;				  //40mV以下清零
000046  9a00              LDR      r2,[sp,#0]
000048  2a1e              CMP      r2,#0x1e
00004a  d200              BCS      |L2.78|
00004c  9100              STR      r1,[sp,#0]
                  |L2.78|
;;;604    	Voltage = var32;
00004e  4bc2              LDR      r3,|L2.856|
000050  9a00              LDR      r2,[sp,#0]
000052  3358              ADDS     r3,r3,#0x58
000054  629a              STR      r2,[r3,#0x28]  ; Run_Control
;;;605    	DISS_Voltage=Voltage;
000056  6a9a              LDR      r2,[r3,#0x28]  ; Run_Control
000058  ee002a10          VMOV     s0,r2
00005c  4ac0              LDR      r2,|L2.864|
00005e  eef80a40          VCVT.F32.U32 s1,s0
;;;606    	DISS_Voltage=DISS_Voltage/1000;//计算显示电压
000062  ed9f0ac0          VLDR     s0,|L2.868|
000066  ee801a80          VDIV.F32 s2,s1,s0
00006a  ed821a00          VSTR     s2,[r2,#0]
;;;607    	var32 = 0;
;;;608    	/*******************负载测量电流转换**************************************/
;;;609    	var32 = Imon1_value;
00006e  4abe              LDR      r2,|L2.872|
000070  6812              LDR      r2,[r2,#0]  ; Imon1_value
000072  9200              STR      r2,[sp,#0]
;;;610    	var32 = var32 * REG_Load_A;  
000074  686a              LDR      r2,[r5,#4]  ; Correct_Parametet
000076  9e00              LDR      r6,[sp,#0]
000078  4372              MULS     r2,r6,r2
00007a  9200              STR      r2,[sp,#0]
;;;611    	if ((Polar1 & 0x01) == 0x01)		  
00007c  7862              LDRB     r2,[r4,#1]  ; correct_por
00007e  07d2              LSLS     r2,r2,#31
000080  d00a              BEQ      |L2.152|
;;;612    	{
;;;613    		if (var32 < REG_LoadA_Offset) 
000082  6842              LDR      r2,[r0,#4]  ; Correct_Strong
000084  9e00              LDR      r6,[sp,#0]
000086  42b2              CMP      r2,r6
000088  d901              BLS      |L2.142|
;;;614    		{
;;;615    			var32 = 0;
00008a  9100              STR      r1,[sp,#0]
00008c  e008              B        |L2.160|
                  |L2.142|
;;;616    		}
;;;617    		else var32 = var32 - REG_LoadA_Offset;
00008e  6842              LDR      r2,[r0,#4]  ; Correct_Strong
000090  9e00              LDR      r6,[sp,#0]
000092  1ab2              SUBS     r2,r6,r2
000094  9200              STR      r2,[sp,#0]
000096  e003              B        |L2.160|
                  |L2.152|
;;;618    	}
;;;619    	else var32 = var32 + REG_LoadA_Offset;
000098  6842              LDR      r2,[r0,#4]  ; Correct_Strong
00009a  9e00              LDR      r6,[sp,#0]
00009c  4432              ADD      r2,r2,r6
00009e  9200              STR      r2,[sp,#0]
                  |L2.160|
;;;620    	var32 = var32 >> 12;
0000a0  9a00              LDR      r2,[sp,#0]
0000a2  0b12              LSRS     r2,r2,#12
0000a4  9200              STR      r2,[sp,#0]
;;;621    	Laod_Current = var32;
0000a6  9a00              LDR      r2,[sp,#0]
0000a8  631a              STR      r2,[r3,#0x30]  ; Run_Control
;;;622    	DISS_Current=Laod_Current;
0000aa  6b1a              LDR      r2,[r3,#0x30]  ; Run_Control
0000ac  ee002a90          VMOV     s1,r2
0000b0  4aae              LDR      r2,|L2.876|
0000b2  eef80a60          VCVT.F32.U32 s1,s1
;;;623    	DISS_Current=DISS_Current/1000;//计算显示电流
0000b6  ee801a80          VDIV.F32 s2,s1,s0
0000ba  ed821a00          VSTR     s2,[r2,#0]
;;;624    	var32 = 0;	
0000be  9100              STR      r1,[sp,#0]
;;;625    	/*************************负载电压和电流控制转换**************************************/
;;;626    	if(flag_Load_CC==1)
0000c0  4aab              LDR      r2,|L2.880|
;;;627    	{
;;;628    		var32 = SET_Current_Laod;
;;;629    		var32=var32<<12;   
;;;630    		if ((Polar1 & 0x04) == 0)			   
;;;631    		{
;;;632    			if (var32 < SET_LoadA_Offset) var32 = 0;
;;;633    			else var32 = var32 - SET_LoadA_Offset;
;;;634    		}
;;;635    		else var32 = var32 + SET_LoadA_Offset;
;;;636    		var32 = var32/SET_LoadA;
;;;637    		var32=var32>>1;
;;;638    		if(Flag_DAC_OFF==0)
;;;639    		{
;;;640    			Contr_Laod = var32;
0000c2  4ead              LDR      r6,|L2.888|
0000c4  7812              LDRB     r2,[r2,#0]            ;626  ; flagD
0000c6  0617              LSLS     r7,r2,#24             ;626
0000c8  4aaa              LDR      r2,|L2.884|
0000ca  6812              LDR      r2,[r2,#0]            ;638
0000cc  d52c              BPL      |L2.296|
0000ce  691f              LDR      r7,[r3,#0x10]         ;628  ; Run_Control
0000d0  9700              STR      r7,[sp,#0]            ;628
0000d2  9f00              LDR      r7,[sp,#0]            ;629
0000d4  033f              LSLS     r7,r7,#12             ;629
0000d6  9700              STR      r7,[sp,#0]            ;629
0000d8  7867              LDRB     r7,[r4,#1]            ;630  ; correct_por
0000da  077f              LSLS     r7,r7,#29             ;630
0000dc  d40d              BMI      |L2.250|
0000de  6887              LDR      r7,[r0,#8]            ;632  ; Correct_Strong
0000e0  f8ddc000          LDR      r12,[sp,#0]           ;632
0000e4  4567              CMP      r7,r12                ;632
0000e6  d901              BLS      |L2.236|
0000e8  9100              STR      r1,[sp,#0]            ;632
0000ea  e00b              B        |L2.260|
                  |L2.236|
0000ec  6887              LDR      r7,[r0,#8]            ;633  ; Correct_Strong
0000ee  f8ddc000          LDR      r12,[sp,#0]           ;633
0000f2  ebac0707          SUB      r7,r12,r7             ;633
0000f6  9700              STR      r7,[sp,#0]            ;633
0000f8  e004              B        |L2.260|
                  |L2.250|
0000fa  6887              LDR      r7,[r0,#8]            ;635  ; Correct_Strong
0000fc  f8ddc000          LDR      r12,[sp,#0]           ;635
000100  4467              ADD      r7,r7,r12             ;635
000102  9700              STR      r7,[sp,#0]            ;635
                  |L2.260|
000104  68af              LDR      r7,[r5,#8]            ;636  ; Correct_Parametet
000106  f8ddc000          LDR      r12,[sp,#0]           ;636
00010a  fbbcf7f7          UDIV     r7,r12,r7             ;636
00010e  9700              STR      r7,[sp,#0]            ;636
000110  9f00              LDR      r7,[sp,#0]            ;637
000112  087f              LSRS     r7,r7,#1              ;637
000114  9700              STR      r7,[sp,#0]            ;637
000116  0712              LSLS     r2,r2,#28             ;638
000118  d401              BMI      |L2.286|
00011a  9a00              LDR      r2,[sp,#0]
00011c  8032              STRH     r2,[r6,#0]
                  |L2.286|
;;;641    		}
;;;642    		if(SET_Current_Laod==0)
00011e  691a              LDR      r2,[r3,#0x10]  ; Run_Control
000120  b902              CBNZ     r2,|L2.292|
;;;643    		{
;;;644    			Contr_Laod=0;
000122  8031              STRH     r1,[r6,#0]
                  |L2.292|
;;;645    		}
;;;646    		var32 = 0;
000124  9100              STR      r1,[sp,#0]
000126  e02b              B        |L2.384|
                  |L2.296|
;;;647    	}
;;;648    	else
;;;649    	{
;;;650    		var32 = SET_Voltage_Laod;
000128  68df              LDR      r7,[r3,#0xc]  ; Run_Control
00012a  9700              STR      r7,[sp,#0]
;;;651    		var32=var32<<12;   
00012c  9f00              LDR      r7,[sp,#0]
00012e  033f              LSLS     r7,r7,#12
000130  9700              STR      r7,[sp,#0]
;;;652    		if ((Polar2 & 0x04) == 0)			   
000132  78a7              LDRB     r7,[r4,#2]  ; correct_por
000134  077f              LSLS     r7,r7,#29
000136  d40d              BMI      |L2.340|
;;;653    		{
;;;654    			if (var32 < SET_LoadA_Offset) var32 = 0;
000138  6887              LDR      r7,[r0,#8]  ; Correct_Strong
00013a  f8ddc000          LDR      r12,[sp,#0]
00013e  4567              CMP      r7,r12
000140  d901              BLS      |L2.326|
000142  9100              STR      r1,[sp,#0]
000144  e00b              B        |L2.350|
                  |L2.326|
;;;655    			else var32 = var32 - SET_LoadV_Offset;
000146  6907              LDR      r7,[r0,#0x10]  ; Correct_Strong
000148  f8ddc000          LDR      r12,[sp,#0]
00014c  ebac0707          SUB      r7,r12,r7
000150  9700              STR      r7,[sp,#0]
000152  e004              B        |L2.350|
                  |L2.340|
;;;656    		}
;;;657    		else var32 = var32 + SET_LoadV_Offset;
000154  6907              LDR      r7,[r0,#0x10]  ; Correct_Strong
000156  f8ddc000          LDR      r12,[sp,#0]
00015a  4467              ADD      r7,r7,r12
00015c  9700              STR      r7,[sp,#0]
                  |L2.350|
;;;658    		var32 = var32/SET_LoadV;
00015e  692f              LDR      r7,[r5,#0x10]  ; Correct_Parametet
000160  f8ddc000          LDR      r12,[sp,#0]
000164  fbbcf7f7          UDIV     r7,r12,r7
000168  9700              STR      r7,[sp,#0]
;;;659    		var32=var32>>1;
00016a  9f00              LDR      r7,[sp,#0]
00016c  087f              LSRS     r7,r7,#1
00016e  9700              STR      r7,[sp,#0]
;;;660    		if(Flag_DAC_OFF==0)
000170  0712              LSLS     r2,r2,#28
000172  d401              BMI      |L2.376|
;;;661    		{
;;;662    			Contr_Laod = var32;
000174  9a00              LDR      r2,[sp,#0]
000176  8032              STRH     r2,[r6,#0]
                  |L2.376|
;;;663    		}
;;;664    		if(SET_Voltage_Laod==0)
000178  68da              LDR      r2,[r3,#0xc]  ; Run_Control
00017a  b902              CBNZ     r2,|L2.382|
;;;665    		{
;;;666    			Contr_Laod=0;
00017c  8031              STRH     r1,[r6,#0]
                  |L2.382|
;;;667    		}
;;;668    		var32 = 0;
00017e  9100              STR      r1,[sp,#0]
                  |L2.384|
;;;669    	}
;;;670    /*****************************内阻值转换*******************************************/
;;;671    	var32 = Rmon_value;
000180  4a7e              LDR      r2,|L2.892|
000182  8812              LDRH     r2,[r2,#0]  ; Rmon_value
000184  9200              STR      r2,[sp,#0]
;;;672    	var32 = var32 * REG_CorrectionR;  
000186  696a              LDR      r2,[r5,#0x14]  ; Correct_Parametet
000188  9e00              LDR      r6,[sp,#0]
00018a  4372              MULS     r2,r6,r2
00018c  9200              STR      r2,[sp,#0]
;;;673    	if ((Polar3 & 0x01) == 0x01)		  
00018e  78e2              LDRB     r2,[r4,#3]  ; correct_por
000190  07d2              LSLS     r2,r2,#31
000192  d00a              BEQ      |L2.426|
;;;674    	{
;;;675    		if (var32 < REG_ReadR_Offset) 
000194  6942              LDR      r2,[r0,#0x14]  ; Correct_Strong
000196  9e00              LDR      r6,[sp,#0]
000198  42b2              CMP      r2,r6
00019a  d901              BLS      |L2.416|
;;;676    		{
;;;677    			var32 = 0;
00019c  9100              STR      r1,[sp,#0]
00019e  e008              B        |L2.434|
                  |L2.416|
;;;678    		}
;;;679    		else var32 = var32 - REG_ReadR_Offset;
0001a0  6942              LDR      r2,[r0,#0x14]  ; Correct_Strong
0001a2  9e00              LDR      r6,[sp,#0]
0001a4  1ab2              SUBS     r2,r6,r2
0001a6  9200              STR      r2,[sp,#0]
0001a8  e003              B        |L2.434|
                  |L2.426|
;;;680    	}
;;;681    	else var32 = var32 + REG_ReadR_Offset;
0001aa  6942              LDR      r2,[r0,#0x14]  ; Correct_Strong
0001ac  9e00              LDR      r6,[sp,#0]
0001ae  4432              ADD      r2,r2,r6
0001b0  9200              STR      r2,[sp,#0]
                  |L2.434|
;;;682    	var32 = var32 >> 12;
0001b2  9a00              LDR      r2,[sp,#0]
0001b4  0b12              LSRS     r2,r2,#12
0001b6  9200              STR      r2,[sp,#0]
;;;683    	if (var32 < 1)
;;;684    	{
;;;685    		var32 = 0;				  //清零
;;;686    	}
;;;687    	R_VLUE = var32;
0001b8  9a00              LDR      r2,[sp,#0]
0001ba  635a              STR      r2,[r3,#0x34]  ; Run_Control
;;;688    	var32 = 0;	
;;;689    	/*****************************稳压电源测量电压转换*******************************************/
;;;690    	var32 = Vmon_value;
0001bc  4a70              LDR      r2,|L2.896|
0001be  8812              LDRH     r2,[r2,#0]  ; Vmon_value
0001c0  9200              STR      r2,[sp,#0]
;;;691    	var32 = var32 * REG_POWERV;  
0001c2  6a2a              LDR      r2,[r5,#0x20]  ; Correct_Parametet
0001c4  9e00              LDR      r6,[sp,#0]
0001c6  4372              MULS     r2,r6,r2
0001c8  9200              STR      r2,[sp,#0]
;;;692    	if ((Polar5 & 0x01) == 0x01)		  
0001ca  7962              LDRB     r2,[r4,#5]  ; correct_por
0001cc  07d2              LSLS     r2,r2,#31
0001ce  d00a              BEQ      |L2.486|
;;;693    	{
;;;694    		if (var32 < REG_POWERV_Offset) 
0001d0  6a02              LDR      r2,[r0,#0x20]  ; Correct_Strong
0001d2  9e00              LDR      r6,[sp,#0]
0001d4  42b2              CMP      r2,r6
0001d6  d901              BLS      |L2.476|
;;;695    		{
;;;696    			var32 = 0;
0001d8  9100              STR      r1,[sp,#0]
0001da  e008              B        |L2.494|
                  |L2.476|
;;;697    		}
;;;698    		else var32 = var32 - REG_POWERV_Offset;
0001dc  6a02              LDR      r2,[r0,#0x20]  ; Correct_Strong
0001de  9e00              LDR      r6,[sp,#0]
0001e0  1ab2              SUBS     r2,r6,r2
0001e2  9200              STR      r2,[sp,#0]
0001e4  e003              B        |L2.494|
                  |L2.486|
;;;699    	}
;;;700    	else var32 = var32 + REG_POWERV_Offset;
0001e6  6a02              LDR      r2,[r0,#0x20]  ; Correct_Strong
0001e8  9e00              LDR      r6,[sp,#0]
0001ea  4432              ADD      r2,r2,r6
0001ec  9200              STR      r2,[sp,#0]
                  |L2.494|
;;;701    	var32 = var32 >> 14;
0001ee  9a00              LDR      r2,[sp,#0]
0001f0  0b92              LSRS     r2,r2,#14
0001f2  9200              STR      r2,[sp,#0]
;;;702    	if (var32 < 40) var32 = 0;				  //40mV以下清零
0001f4  9a00              LDR      r2,[sp,#0]
0001f6  2a28              CMP      r2,#0x28
0001f8  d200              BCS      |L2.508|
0001fa  9100              STR      r1,[sp,#0]
                  |L2.508|
;;;703    	POW_Voltage = var32;
0001fc  9a00              LDR      r2,[sp,#0]
0001fe  625a              STR      r2,[r3,#0x24]  ; Run_Control
;;;704    	DISS_POW_Voltage=POW_Voltage;
000200  6a5a              LDR      r2,[r3,#0x24]  ; Run_Control
000202  ee002a90          VMOV     s1,r2
000206  4a5f              LDR      r2,|L2.900|
000208  eef80a60          VCVT.F32.U32 s1,s1
;;;705    	DISS_POW_Voltage=DISS_POW_Voltage/100;//计算显示电压
00020c  ed9f1a5e          VLDR     s2,|L2.904|
000210  eec01a81          VDIV.F32 s3,s1,s2
000214  edc21a00          VSTR     s3,[r2,#0]
;;;706    	var32 = 0;
;;;707    /*****************************稳压电源测量电流转换*******************************************/
;;;708    	var32 = Imon_value;
000218  4a5c              LDR      r2,|L2.908|
00021a  8812              LDRH     r2,[r2,#0]  ; Imon_value
00021c  9200              STR      r2,[sp,#0]
;;;709    	if(flag_CC_MODE==1)
00021e  4a5c              LDR      r2,|L2.912|
;;;710    	{
;;;711    		var32 = var32 * REG_POWERA;	   
;;;712    		if ((Polar4 & 0x01) == 0x01)			   
;;;713    		{
;;;714    			if (var32 < REG_POWERA_Offset) var32 = 0;
;;;715    			else var32 = var32 - REG_POWERA_Offset;
;;;716    		}
;;;717    		else
;;;718    		{
;;;719    			var32 = var32 + REG_POWERA_Offset;
;;;720    		}	
;;;721    		var32 = var32 >> 14;
;;;722    		Current = var32;;
;;;723    		DISS_POW_Current=Current;
000220  4e5c              LDR      r6,|L2.916|
000222  7812              LDRB     r2,[r2,#0]            ;709  ; flagE
000224  0612              LSLS     r2,r2,#24             ;709
000226  d524              BPL      |L2.626|
000228  69aa              LDR      r2,[r5,#0x18]         ;711  ; Correct_Parametet
00022a  9f00              LDR      r7,[sp,#0]            ;711
00022c  437a              MULS     r2,r7,r2              ;711
00022e  9200              STR      r2,[sp,#0]            ;711
000230  7922              LDRB     r2,[r4,#4]            ;712  ; correct_por
000232  07d2              LSLS     r2,r2,#31             ;712
000234  d00a              BEQ      |L2.588|
000236  6982              LDR      r2,[r0,#0x18]         ;714  ; Correct_Strong
000238  9f00              LDR      r7,[sp,#0]            ;714
00023a  42ba              CMP      r2,r7                 ;714
00023c  d901              BLS      |L2.578|
00023e  9100              STR      r1,[sp,#0]            ;714
000240  e008              B        |L2.596|
                  |L2.578|
000242  6982              LDR      r2,[r0,#0x18]         ;715  ; Correct_Strong
000244  9f00              LDR      r7,[sp,#0]            ;715
000246  1aba              SUBS     r2,r7,r2              ;715
000248  9200              STR      r2,[sp,#0]            ;715
00024a  e003              B        |L2.596|
                  |L2.588|
00024c  6982              LDR      r2,[r0,#0x18]         ;719  ; Correct_Strong
00024e  9f00              LDR      r7,[sp,#0]            ;719
000250  443a              ADD      r2,r2,r7              ;719
000252  9200              STR      r2,[sp,#0]            ;719
                  |L2.596|
000254  9a00              LDR      r2,[sp,#0]            ;721
000256  0b92              LSRS     r2,r2,#14             ;721
000258  9200              STR      r2,[sp,#0]            ;721
00025a  9a00              LDR      r2,[sp,#0]            ;722
00025c  62da              STR      r2,[r3,#0x2c]         ;722  ; Run_Control
00025e  6ada              LDR      r2,[r3,#0x2c]  ; Run_Control
000260  ee002a90          VMOV     s1,r2
000264  eef80a60          VCVT.F32.U32 s1,s1
;;;724    		DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
000268  ee801a80          VDIV.F32 s2,s1,s0
00026c  ed861a00          VSTR     s2,[r6,#0]
000270  e023              B        |L2.698|
                  |L2.626|
;;;725    	}
;;;726    	else
;;;727    	{
;;;728    		var32 = var32 * CON_POWERA;	   
000272  6aaa              LDR      r2,[r5,#0x28]  ; Correct_Parametet
000274  9f00              LDR      r7,[sp,#0]
000276  437a              MULS     r2,r7,r2
000278  9200              STR      r2,[sp,#0]
;;;729    		if ((Polar3 & 0x04) == 0x04)			   
00027a  78e2              LDRB     r2,[r4,#3]  ; correct_por
00027c  0752              LSLS     r2,r2,#29
00027e  d50a              BPL      |L2.662|
;;;730    		{
;;;731    			if (var32 < CON_POWERA_Offset) var32 = 0;
000280  6a82              LDR      r2,[r0,#0x28]  ; Correct_Strong
000282  9f00              LDR      r7,[sp,#0]
000284  42ba              CMP      r2,r7
000286  d901              BLS      |L2.652|
000288  9100              STR      r1,[sp,#0]
00028a  e008              B        |L2.670|
                  |L2.652|
;;;732    			else var32 = var32 - CON_POWERA_Offset;
00028c  6a82              LDR      r2,[r0,#0x28]  ; Correct_Strong
00028e  9f00              LDR      r7,[sp,#0]
000290  1aba              SUBS     r2,r7,r2
000292  9200              STR      r2,[sp,#0]
000294  e003              B        |L2.670|
                  |L2.662|
;;;733    		}
;;;734    		else
;;;735    		{
;;;736    			var32 = var32 + CON_POWERA_Offset;
000296  6a82              LDR      r2,[r0,#0x28]  ; Correct_Strong
000298  9f00              LDR      r7,[sp,#0]
00029a  443a              ADD      r2,r2,r7
00029c  9200              STR      r2,[sp,#0]
                  |L2.670|
;;;737    		}	
;;;738    		var32 = var32 >> 14;
00029e  9a00              LDR      r2,[sp,#0]
0002a0  0b92              LSRS     r2,r2,#14
0002a2  9200              STR      r2,[sp,#0]
;;;739    		Current = var32;;
0002a4  9a00              LDR      r2,[sp,#0]
0002a6  62da              STR      r2,[r3,#0x2c]  ; Run_Control
;;;740    		DISS_POW_Current=Current;
0002a8  6ada              LDR      r2,[r3,#0x2c]  ; Run_Control
0002aa  ee002a90          VMOV     s1,r2
0002ae  eef80a60          VCVT.F32.U32 s1,s1
;;;741    		DISS_POW_Current=DISS_POW_Current/1000;//计算显示电流
0002b2  ee801a80          VDIV.F32 s2,s1,s0
0002b6  ed861a00          VSTR     s2,[r6,#0]
                  |L2.698|
;;;742    	}
;;;743    /**************************稳压电源设置电压转换******************************************/
;;;744    	var32 = SET_Voltage;
0002ba  685a              LDR      r2,[r3,#4]  ; Run_Control
0002bc  9200              STR      r2,[sp,#0]
;;;745    	var32=var32<<14;   
0002be  9a00              LDR      r2,[sp,#0]
0002c0  0392              LSLS     r2,r2,#14
0002c2  9200              STR      r2,[sp,#0]
;;;746    	if ((Polar5 & 0x04) == 0)			   
0002c4  7962              LDRB     r2,[r4,#5]  ; correct_por
0002c6  0752              LSLS     r2,r2,#29
0002c8  d40a              BMI      |L2.736|
;;;747    	{
;;;748    		if (var32 < SET_POWERV_Offset) var32 = 0;
0002ca  6a42              LDR      r2,[r0,#0x24]  ; Correct_Strong
0002cc  9e00              LDR      r6,[sp,#0]
0002ce  42b2              CMP      r2,r6
0002d0  d901              BLS      |L2.726|
0002d2  9100              STR      r1,[sp,#0]
0002d4  e008              B        |L2.744|
                  |L2.726|
;;;749    		else var32 = var32 - SET_POWERV_Offset;
0002d6  6a42              LDR      r2,[r0,#0x24]  ; Correct_Strong
0002d8  9e00              LDR      r6,[sp,#0]
0002da  1ab2              SUBS     r2,r6,r2
0002dc  9200              STR      r2,[sp,#0]
0002de  e003              B        |L2.744|
                  |L2.736|
;;;750    	}
;;;751    	else var32 = var32 + SET_POWERV_Offset;
0002e0  6a42              LDR      r2,[r0,#0x24]  ; Correct_Strong
0002e2  9e00              LDR      r6,[sp,#0]
0002e4  4432              ADD      r2,r2,r6
0002e6  9200              STR      r2,[sp,#0]
                  |L2.744|
;;;752    	var32 = var32/SET_POWERV;
0002e8  6a6a              LDR      r2,[r5,#0x24]  ; Correct_Parametet
0002ea  9e00              LDR      r6,[sp,#0]
0002ec  fbb6f2f2          UDIV     r2,r6,r2
0002f0  9200              STR      r2,[sp,#0]
;;;753    	var32=var32>>1;
0002f2  9a00              LDR      r2,[sp,#0]
0002f4  0852              LSRS     r2,r2,#1
0002f6  9200              STR      r2,[sp,#0]
;;;754    	Contr_Voltage = var32;
0002f8  4a27              LDR      r2,|L2.920|
0002fa  9e00              LDR      r6,[sp,#0]
0002fc  8016              STRH     r6,[r2,#0]
;;;755    	if(SET_Voltage==0)
0002fe  685e              LDR      r6,[r3,#4]  ; Run_Control
000300  b906              CBNZ     r6,|L2.772|
;;;756    	{
;;;757    		Contr_Voltage=0;
000302  8011              STRH     r1,[r2,#0]
                  |L2.772|
;;;758    	}
;;;759    	var32 = 0;
;;;760    /**************************稳压电源设置电流转换**************************************/
;;;761    	var32 = SET_Current;
000304  689a              LDR      r2,[r3,#8]  ; Run_Control
000306  9200              STR      r2,[sp,#0]
;;;762    	var32=var32<<14;   
000308  9a00              LDR      r2,[sp,#0]
00030a  0392              LSLS     r2,r2,#14
00030c  9200              STR      r2,[sp,#0]
;;;763    	if ((Polar4 & 0x04) == 0)			   
00030e  7922              LDRB     r2,[r4,#4]  ; correct_por
000310  0752              LSLS     r2,r2,#29
000312  d40a              BMI      |L2.810|
;;;764    	{
;;;765    		if (var32 < SET_POWERA_Offset) var32 = 0;
000314  69c2              LDR      r2,[r0,#0x1c]  ; Correct_Strong
000316  9c00              LDR      r4,[sp,#0]
000318  42a2              CMP      r2,r4
00031a  d901              BLS      |L2.800|
00031c  9100              STR      r1,[sp,#0]
00031e  e008              B        |L2.818|
                  |L2.800|
;;;766    		else var32 = var32 - SET_POWERA_Offset;
000320  69c0              LDR      r0,[r0,#0x1c]  ; Correct_Strong
000322  9a00              LDR      r2,[sp,#0]
000324  1a10              SUBS     r0,r2,r0
000326  9000              STR      r0,[sp,#0]
000328  e003              B        |L2.818|
                  |L2.810|
;;;767    	}
;;;768    	else var32 = var32 + SET_POWERA_Offset;
00032a  69c0              LDR      r0,[r0,#0x1c]  ; Correct_Strong
00032c  9a00              LDR      r2,[sp,#0]
00032e  4410              ADD      r0,r0,r2
000330  9000              STR      r0,[sp,#0]
                  |L2.818|
;;;769    	var32 = var32/SET_POWERA;
000332  69e8              LDR      r0,[r5,#0x1c]  ; Correct_Parametet
000334  9a00              LDR      r2,[sp,#0]
000336  fbb2f0f0          UDIV     r0,r2,r0
00033a  9000              STR      r0,[sp,#0]
;;;770    	var32=var32>>1;
00033c  9800              LDR      r0,[sp,#0]
00033e  0840              LSRS     r0,r0,#1
000340  9000              STR      r0,[sp,#0]
;;;771    	Contr_Current = var32;
000342  4816              LDR      r0,|L2.924|
000344  9a00              LDR      r2,[sp,#0]
000346  8002              STRH     r2,[r0,#0]
;;;772    	if(SET_Current==0)
000348  689a              LDR      r2,[r3,#8]  ; Run_Control
00034a  b902              CBNZ     r2,|L2.846|
;;;773    	{
;;;774    		Contr_Current=0;
00034c  8001              STRH     r1,[r0,#0]
                  |L2.846|
;;;775    	}
;;;776    	
;;;777    	var32 = 0;
00034e  9100              STR      r1,[sp,#0]
;;;778    }
000350  bdf8              POP      {r3-r7,pc}
;;;779    /********************************************************************************
                          ENDP

000352  0000              DCW      0x0000
                  |L2.852|
                          DCD      Vmon1_value
                  |L2.856|
                          DCD      ||.bss||
                  |L2.860|
                          DCD      ||area_number.8||+0x1c
                  |L2.864|
                          DCD      DISS_Voltage
                  |L2.868|
000364  447a0000          DCFS     0x447a0000 ; 1000
                  |L2.872|
                          DCD      Imon1_value
                  |L2.876|
                          DCD      DISS_Current
                  |L2.880|
                          DCD      flagD
                  |L2.884|
                          DCD      flagB
                  |L2.888|
                          DCD      Contr_Laod
                  |L2.892|
                          DCD      Rmon_value
                  |L2.896|
                          DCD      Vmon_value
                  |L2.900|
                          DCD      DISS_POW_Voltage
                  |L2.904|
000388  42c80000          DCFS     0x42c80000 ; 100
                  |L2.908|
                          DCD      Imon_value
                  |L2.912|
                          DCD      flagE
                  |L2.916|
                          DCD      DISS_POW_Current
                  |L2.920|
                          DCD      Contr_Voltage
                  |L2.924|
                          DCD      Contr_Current

                          AREA ||i.UART_Action||, CODE, READONLY, ALIGN=2

                  UART_Action PROC
;;;44     //===========================MODBUS协议=============================//
;;;45     void UART_Action(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;46     {//RUT格式：
000004  b087              SUB      sp,sp,#0x1c
;;;47     	//ADDR  命令码  读寄存器的起始地址高   读寄存器的起始地址低  读数据字个数高字节   读数据个数低字节  CRC高 CRC低
;;;48     	//返回格式：ADDR 命令码 返回数据字节数  数据高  数据低 ..... CRC高  CRC低
;;;49     	if (UART_Buffer_Rece[0] == ADDR)
000006  f8dfa3f8          LDR      r10,|L3.1024|
00000a  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
00000e  4efd              LDR      r6,|L3.1028|
000010  7871              LDRB     r1,[r6,#1]  ; ADDR
;;;50     	{
;;;51     		if (UART_Buffer_Rece[1] == (0x03))	//命令3 读数据   
;;;52     		{																		 
;;;53     			vu8 i;
;;;54     			vu16 crc_result;
;;;55     			crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;56     			if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )
;;;57     			{
;;;58     				if (UART_Buffer_Rece[3] < 0x07)    								//如果寄存器在可读范围内
;;;59     				{
;;;60     					if ((UART_Buffer_Rece[3] + UART_Buffer_Rece[5]) < 0x0F)		//如果最后一个读取的寄存器地址在可读范围内
;;;61     					{							
;;;62     						UART_Buffer_Send[0] = ADDR;
000012  4bfd              LDR      r3,|L3.1032|
;;;63     						UART_Buffer_Send[1] = 0x03;
;;;64     						UART_Buffer_Send[2] = UART_Buffer_Rece[5]*2;
;;;65     						for (i=0;i<UART_Buffer_Send[2];i++)
;;;66     						{
;;;67     							if ((i % 2) == 0) UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2] >> 8;
;;;68     							else UART_Buffer_Send[3 + i] = Run_Control[UART_Buffer_Rece[3] + i / 2];														
;;;69     						}
;;;70     						crc_result = Hardware_CRC(UART_Buffer_Send,UART_Buffer_Send[2] + 3);
;;;71     						UART_Buffer_Send[3 + UART_Buffer_Send[2]] = crc_result >> 8;
;;;72     						UART_Buffer_Send[4 + UART_Buffer_Send[2]] = crc_result;
;;;73     						Transmit_BUFFERsize = UART_Buffer_Send[2] + 5;
000014  4ffd              LDR      r7,|L3.1036|
;;;74     						UART_SEND_flag=1;
000016  4cfe              LDR      r4,|L3.1040|
000018  4dfe              LDR      r5,|L3.1044|
00001a  4288              CMP      r0,r1                 ;49
00001c  d161              BNE      |L3.226|
00001e  f89a0001          LDRB     r0,[r10,#1]           ;51  ; UART_Buffer_Rece
000022  2803              CMP      r0,#3                 ;51
000024  d15d              BNE      |L3.226|
000026  f89a0007          LDRB     r0,[r10,#7]           ;55  ; UART_Buffer_Rece
00002a  f89a1006          LDRB     r1,[r10,#6]           ;55  ; UART_Buffer_Rece
00002e  eb002001          ADD      r0,r0,r1,LSL #8       ;55
000032  9005              STR      r0,[sp,#0x14]         ;55
000034  2106              MOVS     r1,#6                 ;56
000036  4650              MOV      r0,r10                ;56
000038  f7fffffe          BL       Hardware_CRC
00003c  f8bd1014          LDRH     r1,[sp,#0x14]         ;56
000040  4288              CMP      r0,r1                 ;56
000042  d002              BEQ      |L3.74|
000044  f8bd0014          LDRH     r0,[sp,#0x14]         ;56
000048  bbe8              CBNZ     r0,|L3.198|
                  |L3.74|
00004a  f89a0003          LDRB     r0,[r10,#3]           ;58  ; UART_Buffer_Rece
00004e  2807              CMP      r0,#7                 ;58
000050  d247              BCS      |L3.226|
000052  f89a0003          LDRB     r0,[r10,#3]           ;60  ; UART_Buffer_Rece
000056  f89a1005          LDRB     r1,[r10,#5]           ;60  ; UART_Buffer_Rece
00005a  4408              ADD      r0,r0,r1              ;60
00005c  280f              CMP      r0,#0xf               ;60
00005e  d240              BCS      |L3.226|
000060  7870              LDRB     r0,[r6,#1]            ;62  ; ADDR
000062  7018              STRB     r0,[r3,#0]            ;62
000064  2003              MOVS     r0,#3                 ;63
000066  7058              STRB     r0,[r3,#1]            ;63
000068  f89a0005          LDRB     r0,[r10,#5]           ;64  ; UART_Buffer_Rece
00006c  0040              LSLS     r0,r0,#1              ;64
00006e  7098              STRB     r0,[r3,#2]            ;64
000070  2000              MOVS     r0,#0                 ;65
000072  9006              STR      r0,[sp,#0x18]         ;65
000074  e013              B        |L3.158|
                  |L3.118|
000076  f89d0018          LDRB     r0,[sp,#0x18]         ;67
00007a  07c0              LSLS     r0,r0,#31             ;67
00007c  d050              BEQ      |L3.288|
00007e  f89a0003          LDRB     r0,[r10,#3]           ;68  ; UART_Buffer_Rece
000082  f89d1018          LDRB     r1,[sp,#0x18]         ;68
000086  eb000051          ADD      r0,r0,r1,LSR #1       ;68
00008a  f8550020          LDR      r0,[r5,r0,LSL #2]     ;68
00008e  f89d1018          LDRB     r1,[sp,#0x18]         ;68
000092  4419              ADD      r1,r1,r3              ;68
000094  70c8              STRB     r0,[r1,#3]            ;68
                  |L3.150|
000096  f89d0018          LDRB     r0,[sp,#0x18]         ;65
00009a  1c40              ADDS     r0,r0,#1              ;65
00009c  9006              STR      r0,[sp,#0x18]         ;65
                  |L3.158|
00009e  7898              LDRB     r0,[r3,#2]            ;65  ; UART_Buffer_Send
0000a0  f89d1018          LDRB     r1,[sp,#0x18]         ;65
0000a4  4288              CMP      r0,r1                 ;65
0000a6  d8e6              BHI      |L3.118|
0000a8  7898              LDRB     r0,[r3,#2]            ;70  ; UART_Buffer_Send
0000aa  1cc0              ADDS     r0,r0,#3              ;70
0000ac  b2c1              UXTB     r1,r0                 ;70
0000ae  48d6              LDR      r0,|L3.1032|
0000b0  f7fffffe          BL       Hardware_CRC
0000b4  9005              STR      r0,[sp,#0x14]         ;70
0000b6  f8bd0014          LDRH     r0,[sp,#0x14]         ;71
0000ba  789a              LDRB     r2,[r3,#2]            ;71  ; UART_Buffer_Send
0000bc  0a01              LSRS     r1,r0,#8              ;71
0000be  48d2              LDR      r0,|L3.1032|
0000c0  1cc0              ADDS     r0,r0,#3              ;71
0000c2  5411              STRB     r1,[r2,r0]            ;71
0000c4  e000              B        |L3.200|
                  |L3.198|
0000c6  e00c              B        |L3.226|
                  |L3.200|
0000c8  f8bd0014          LDRH     r0,[sp,#0x14]         ;72
0000cc  789a              LDRB     r2,[r3,#2]            ;72  ; UART_Buffer_Send
0000ce  49ce              LDR      r1,|L3.1032|
0000d0  1d09              ADDS     r1,r1,#4              ;72
0000d2  5450              STRB     r0,[r2,r1]            ;72
0000d4  7898              LDRB     r0,[r3,#2]            ;73  ; UART_Buffer_Send
0000d6  1d40              ADDS     r0,r0,#5              ;73
0000d8  7038              STRB     r0,[r7,#0]            ;73
0000da  6820              LDR      r0,[r4,#0]  ; flagA
0000dc  f0400010          ORR      r0,r0,#0x10
0000e0  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.226|
;;;75     					}
;;;76     				}
;;;77     			}	
;;;78     		}
;;;79     	} 
;;;80     //===============================写寄存器=================================
;;;81     	if ((UART_Buffer_Rece[0] == 0) || (UART_Buffer_Rece[0] == ADDR) || (UART_Buffer_Rece[0] == ((ADDR-1)/4+100)))	 
0000e2  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0000e6  b180              CBZ      r0,|L3.266|
0000e8  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
0000ec  7871              LDRB     r1,[r6,#1]  ; ADDR
0000ee  4288              CMP      r0,r1
0000f0  d00b              BEQ      |L3.266|
0000f2  7870              LDRB     r0,[r6,#1]  ; ADDR
0000f4  1e40              SUBS     r0,r0,#1
0000f6  17c1              ASRS     r1,r0,#31
0000f8  eb007091          ADD      r0,r0,r1,LSR #30
0000fc  2164              MOVS     r1,#0x64
0000fe  eb0100a0          ADD      r0,r1,r0,ASR #2
000102  f89a1000          LDRB     r1,[r10,#0]  ; UART_Buffer_Rece
000106  4288              CMP      r0,r1
000108  d17b              BNE      |L3.514|
                  |L3.266|
;;;82     	{
;;;83     		vu8 var8;
;;;84     		vu8 a=0;
00010a  f04f0900          MOV      r9,#0
00010e  f8cd9014          STR      r9,[sp,#0x14]
;;;85     		vu16 var16;
;;;86     		vu16 crc_result;
;;;87     //=========================以下命令6 写单个寄存器===========================
;;;88     		if (UART_Buffer_Rece[1] == 6)                                 //判断第二个字节是否为命令6
000112  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;89     		{
;;;90     			if (UART_Buffer_Rece[3] < 0x05)							  //判断需要写的地址是否在可写范围内
;;;91     			{
;;;92     				crc_result = (UART_Buffer_Rece[6] << 8) + UART_Buffer_Rece[7];
;;;93     				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,6)) ||(crc_result == 0) )		  //检查CRC
;;;94     				{
;;;95     					var16 = (UART_Buffer_Rece[4] << 8) + UART_Buffer_Rece[5];	//第5 6个字节为要写入的数据
;;;96     					var8 = UART_Buffer_Rece[3];	        						//第3 4个字节为要写入的地址
;;;97     					Run_Control[var8] = var16;			    //将数据写入指定的地址
;;;98     
;;;99     					if (UART_Buffer_Rece[0] == ADDR)							//广播模式下不返回数据
;;;100    					{
;;;101    						for (a=0;a<8;a++)
;;;102    						{UART_Buffer_Send[a] = UART_Buffer_Rece[a];}
;;;103    						Transmit_BUFFERsize = 8;						//原样数据返回，不计算CRC
000116  f04f0808          MOV      r8,#8
00011a  2806              CMP      r0,#6                 ;88
00011c  d00e              BEQ      |L3.316|
00011e  e050              B        |L3.450|
                  |L3.288|
000120  f89a0003          LDRB     r0,[r10,#3]           ;67  ; UART_Buffer_Rece
000124  f89d1018          LDRB     r1,[sp,#0x18]         ;67
000128  eb000051          ADD      r0,r0,r1,LSR #1       ;67
00012c  f8550020          LDR      r0,[r5,r0,LSL #2]     ;67
000130  f89d1018          LDRB     r1,[sp,#0x18]         ;67
000134  0a00              LSRS     r0,r0,#8              ;67
000136  4419              ADD      r1,r1,r3              ;67
000138  70c8              STRB     r0,[r1,#3]            ;67
00013a  e7ac              B        |L3.150|
                  |L3.316|
00013c  f89a0003          LDRB     r0,[r10,#3]           ;90  ; UART_Buffer_Rece
000140  2805              CMP      r0,#5                 ;90
000142  d23e              BCS      |L3.450|
000144  f89a0007          LDRB     r0,[r10,#7]           ;92  ; UART_Buffer_Rece
000148  f89a1006          LDRB     r1,[r10,#6]           ;92  ; UART_Buffer_Rece
00014c  eb002001          ADD      r0,r0,r1,LSL #8       ;92
000150  9003              STR      r0,[sp,#0xc]          ;92
000152  2106              MOVS     r1,#6                 ;93
000154  48aa              LDR      r0,|L3.1024|
000156  f7fffffe          BL       Hardware_CRC
00015a  f8bd100c          LDRH     r1,[sp,#0xc]          ;93
00015e  4288              CMP      r0,r1                 ;93
000160  d002              BEQ      |L3.360|
000162  f8bd000c          LDRH     r0,[sp,#0xc]          ;93
000166  bb60              CBNZ     r0,|L3.450|
                  |L3.360|
000168  f89a0005          LDRB     r0,[r10,#5]           ;95  ; UART_Buffer_Rece
00016c  f89a1004          LDRB     r1,[r10,#4]           ;95  ; UART_Buffer_Rece
000170  eb002001          ADD      r0,r0,r1,LSL #8       ;95
000174  9004              STR      r0,[sp,#0x10]         ;95
000176  f89a0003          LDRB     r0,[r10,#3]           ;96  ; UART_Buffer_Rece
00017a  9006              STR      r0,[sp,#0x18]         ;96
00017c  f8bd0010          LDRH     r0,[sp,#0x10]         ;97
000180  f89d1018          LDRB     r1,[sp,#0x18]         ;97
000184  f8450021          STR      r0,[r5,r1,LSL #2]     ;97
000188  f89a0000          LDRB     r0,[r10,#0]           ;99  ; UART_Buffer_Rece
00018c  7871              LDRB     r1,[r6,#1]            ;99  ; ADDR
00018e  4288              CMP      r0,r1                 ;99
000190  d117              BNE      |L3.450|
000192  f8cd9014          STR      r9,[sp,#0x14]         ;101
000196  e00a              B        |L3.430|
                  |L3.408|
000198  f89d0014          LDRB     r0,[sp,#0x14]         ;102
00019c  f81a0000          LDRB     r0,[r10,r0]           ;102
0001a0  f89d1014          LDRB     r1,[sp,#0x14]         ;102
0001a4  5458              STRB     r0,[r3,r1]            ;102
0001a6  f89d0014          LDRB     r0,[sp,#0x14]         ;101
0001aa  1c40              ADDS     r0,r0,#1              ;101
0001ac  9005              STR      r0,[sp,#0x14]         ;101
                  |L3.430|
0001ae  f89d0014          LDRB     r0,[sp,#0x14]         ;101
0001b2  2808              CMP      r0,#8                 ;101
0001b4  d3f0              BCC      |L3.408|
0001b6  f8878000          STRB     r8,[r7,#0]
;;;104    						UART_SEND_flag=1;
0001ba  6820              LDR      r0,[r4,#0]  ; flagA
0001bc  f0400010          ORR      r0,r0,#0x10
0001c0  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.450|
;;;105    					}
;;;106    				}
;;;107    			}
;;;108    		}
;;;109    //=======================================以下是命令16，连写寄存器===========================================
;;;110    //功能码16格式:
;;;111    //     地址 命令 写入起始地址高  写入起始地址低 写入字数高  写入字数低 写入字节数  数据高 数据低 ......CRC高 CRC低
;;;112    //返回数据格式:
;;;113    //     地址 命令 写入起始地址高  写入起始地址低  写入字节数高 写入字节数低  CRC高  CRC低 
;;;114    		if (UART_Buffer_Rece[1] == 16)										  
0001c2  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
0001c6  2810              CMP      r0,#0x10
0001c8  d15b              BNE      |L3.642|
;;;115    		{	
;;;116    			if ((UART_Buffer_Rece[6] == 6) && (UART_Buffer_Rece[3] == 0x00))	//规定连写寄存器的个数
0001ca  f89a0006          LDRB     r0,[r10,#6]  ; UART_Buffer_Rece
0001ce  2806              CMP      r0,#6
0001d0  d157              BNE      |L3.642|
0001d2  f89a0003          LDRB     r0,[r10,#3]  ; UART_Buffer_Rece
0001d6  b9a0              CBNZ     r0,|L3.514|
;;;117    			{
;;;118    				crc_result = (UART_Buffer_Rece[13] << 8) + UART_Buffer_Rece[14];
0001d8  f89a000e          LDRB     r0,[r10,#0xe]  ; UART_Buffer_Rece
0001dc  f89a100d          LDRB     r1,[r10,#0xd]  ; UART_Buffer_Rece
0001e0  eb002001          ADD      r0,r0,r1,LSL #8
0001e4  9003              STR      r0,[sp,#0xc]
;;;119    				if ((crc_result == Hardware_CRC(UART_Buffer_Rece,13)) ||(crc_result == 0) )	   //检查CRC
0001e6  210d              MOVS     r1,#0xd
0001e8  4885              LDR      r0,|L3.1024|
0001ea  f7fffffe          BL       Hardware_CRC
0001ee  f8bd100c          LDRH     r1,[sp,#0xc]
0001f2  4288              CMP      r0,r1
0001f4  d002              BEQ      |L3.508|
0001f6  f8bd000c          LDRH     r0,[sp,#0xc]
0001fa  b910              CBNZ     r0,|L3.514|
                  |L3.508|
;;;120    				{												
;;;121    					for (var8=0;var8<3;var8++) Run_Control[var8] = (UART_Buffer_Rece[var8*2+7] << 8) + UART_Buffer_Rece[var8*2+8];
0001fc  f8cd9018          STR      r9,[sp,#0x18]
000200  e014              B        |L3.556|
                  |L3.514|
000202  e03e              B        |L3.642|
                  |L3.516|
000204  f89d0018          LDRB     r0,[sp,#0x18]
000208  eb0a0040          ADD      r0,r10,r0,LSL #1
00020c  7a00              LDRB     r0,[r0,#8]
00020e  f89d1018          LDRB     r1,[sp,#0x18]
000212  eb0a0141          ADD      r1,r10,r1,LSL #1
000216  79c9              LDRB     r1,[r1,#7]
000218  eb002001          ADD      r0,r0,r1,LSL #8
00021c  f89d1018          LDRB     r1,[sp,#0x18]
000220  f8450021          STR      r0,[r5,r1,LSL #2]
000224  f89d0018          LDRB     r0,[sp,#0x18]
000228  1c40              ADDS     r0,r0,#1
00022a  9006              STR      r0,[sp,#0x18]
                  |L3.556|
00022c  f89d0018          LDRB     r0,[sp,#0x18]
000230  2803              CMP      r0,#3
000232  d3e7              BCC      |L3.516|
;;;122    
;;;123    					if (UART_Buffer_Rece[0] == ADDR)					  //广播模式不返回数据
000234  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
000238  7871              LDRB     r1,[r6,#1]  ; ADDR
00023a  4288              CMP      r0,r1
00023c  d121              BNE      |L3.642|
;;;124    					{
;;;125    						UART_Buffer_Send[0] = ADDR;
00023e  7870              LDRB     r0,[r6,#1]  ; ADDR
000240  7018              STRB     r0,[r3,#0]
;;;126    						UART_Buffer_Send[1] = 16;
000242  2010              MOVS     r0,#0x10
000244  7058              STRB     r0,[r3,#1]
;;;127    						UART_Buffer_Send[2] = UART_Buffer_Rece[2];
000246  f89a0002          LDRB     r0,[r10,#2]  ; UART_Buffer_Rece
00024a  7098              STRB     r0,[r3,#2]
;;;128    						UART_Buffer_Send[3] = UART_Buffer_Rece[3];
00024c  f89a0003          LDRB     r0,[r10,#3]  ; UART_Buffer_Rece
000250  70d8              STRB     r0,[r3,#3]
;;;129    						UART_Buffer_Send[4] = UART_Buffer_Rece[4];
000252  f89a0004          LDRB     r0,[r10,#4]  ; UART_Buffer_Rece
000256  7118              STRB     r0,[r3,#4]
;;;130    						UART_Buffer_Send[5] = UART_Buffer_Rece[5];
000258  f89a0005          LDRB     r0,[r10,#5]  ; UART_Buffer_Rece
00025c  7158              STRB     r0,[r3,#5]
;;;131    						crc_result = Hardware_CRC(UART_Buffer_Send,6);	 //计算CRC码
00025e  2106              MOVS     r1,#6
000260  4869              LDR      r0,|L3.1032|
000262  f7fffffe          BL       Hardware_CRC
000266  9003              STR      r0,[sp,#0xc]
;;;132    						UART_Buffer_Send[6] = crc_result>>8;
000268  f8bd000c          LDRH     r0,[sp,#0xc]
00026c  0a00              LSRS     r0,r0,#8
00026e  7198              STRB     r0,[r3,#6]
;;;133    						UART_Buffer_Send[7] = crc_result;				 
000270  f8bd000c          LDRH     r0,[sp,#0xc]
000274  71d8              STRB     r0,[r3,#7]
;;;134    						Transmit_BUFFERsize = 8;					     //设置发送字节数长度
000276  f8878000          STRB     r8,[r7,#0]
;;;135    						UART_SEND_flag=1;
00027a  6820              LDR      r0,[r4,#0]  ; flagA
00027c  f0400010          ORR      r0,r0,#0x10
000280  6020              STR      r0,[r4,#0]  ; flagA
                  |L3.642|
;;;136    					}
;;;137    				}
;;;138    			}			 
;;;139    		}
;;;140    	}
;;;141    /*************************************以下为校准部分**************************************************************************/
;;;142    	if (((UART_Buffer_Rece[0] == 0x01)&&(UART_Buffer_Rece[2] == 0xA5))||(flag_ADJ_ON==1))			   //电压校准
000282  f89a0000          LDRB     r0,[r10,#0]  ; UART_Buffer_Rece
000286  f8df9190          LDR      r9,|L3.1048|
00028a  2801              CMP      r0,#1
00028c  d103              BNE      |L3.662|
00028e  f89a0002          LDRB     r0,[r10,#2]  ; UART_Buffer_Rece
000292  28a5              CMP      r0,#0xa5
000294  d003              BEQ      |L3.670|
                  |L3.662|
000296  f8990000          LDRB     r0,[r9,#0]  ; flagF
00029a  0780              LSLS     r0,r0,#30
00029c  d57e              BPL      |L3.924|
                  |L3.670|
;;;143    	{ 
;;;144    		if(UART_Buffer_Rece[1] == 0x01)
00029e  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;145    		{
;;;146    			flag_ADJ_VL=0;
;;;147    			Modify_A_READ = Vmon1_value;//测量电压值
0002a2  f8dfb178          LDR      r11,|L3.1052|
0002a6  2801              CMP      r0,#1                 ;144
0002a8  d10f              BNE      |L3.714|
0002aa  f8d90000          LDR      r0,[r9,#0]            ;146  ; flagF
0002ae  f0200004          BIC      r0,r0,#4              ;146
0002b2  f8c90000          STR      r0,[r9,#0]            ;146  ; flagF
0002b6  f8db0000          LDR      r0,[r11,#0]  ; Vmon1_value
0002ba  6070              STR      r0,[r6,#4]  ; Modify_A_READ
;;;148    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
0002bc  f89a0004          LDRB     r0,[r10,#4]  ; UART_Buffer_Rece
0002c0  f89a1003          LDRB     r1,[r10,#3]  ; UART_Buffer_Rece
0002c4  eb002001          ADD      r0,r0,r1,LSL #8
0002c8  60f0              STR      r0,[r6,#0xc]  ; Modify_A_ACT
                  |L3.714|
;;;149    		}
;;;150    		if (UART_Buffer_Rece[1] == 0x02)			   //电压测量校准完成
0002ca  f89a0001          LDRB     r0,[r10,#1]  ; UART_Buffer_Rece
;;;151    		{
;;;152    			vu32 var16;
;;;153    			vu32 var32a;
;;;154    			vu32 var32b;
;;;155    			
;;;156    			vu32 var16a;
;;;157    			vu32 var32c;
;;;158    			vu32 var32d;
;;;159    			Modify_B_READ =Vmon1_value;//测量电压值
;;;160    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
;;;161    			var32a = Modify_B_ACT;
;;;162    			var32a = var32a - Modify_A_ACT;
;;;163    			var32a = var32a << 12;
;;;164    			var16 = Modify_B_READ - Modify_A_READ;
;;;165    			var32a = var32a / var16;
;;;166    			REG_CorrectionV = var32a;
0002ce  f8df8144          LDR      r8,|L3.1044|
;;;167    			var32a=0;
;;;168    			var32a = Modify_B_ACT;
;;;169    			var32a = var32a << 12;
;;;170    			var32b = Modify_B_READ;
;;;171    			var32b = var32b * REG_CorrectionV;
;;;172    			if (var32a < var32b)
;;;173    			{
;;;174    				var32b = var32b - var32a;
;;;175    				REG_ReadV_Offset = var32b;
;;;176    				Polar |= 0x01;
0002d2  4c4c              LDR      r4,|L3.1028|
0002d4  f1a80858          SUB      r8,r8,#0x58           ;166
0002d8  341c              ADDS     r4,r4,#0x1c
;;;177    			}
;;;178    			else 
;;;179    			{
;;;180    				var32a = var32a - var32b;
;;;181    				REG_ReadV_Offset = var32a;
;;;182    				Polar &= ~0x01;
;;;183    			}			
;;;184    			Flash_Write_all();	//参数写进FLASH
;;;185    			Flag_DAC_OFF=0;
0002da  4f51              LDR      r7,|L3.1056|
0002dc  f108052c          ADD      r5,r8,#0x2c           ;175
0002e0  2802              CMP      r0,#2                 ;150
0002e2  d149              BNE      |L3.888|
0002e4  f8db0000          LDR      r0,[r11,#0]           ;159  ; Vmon1_value
0002e8  6130              STR      r0,[r6,#0x10]         ;159  ; Modify_B_READ
0002ea  f89a0004          LDRB     r0,[r10,#4]           ;160  ; UART_Buffer_Rece
0002ee  f89a1003          LDRB     r1,[r10,#3]           ;160  ; UART_Buffer_Rece
0002f2  eb002001          ADD      r0,r0,r1,LSL #8       ;160
0002f6  61b0              STR      r0,[r6,#0x18]         ;160  ; Modify_B_ACT
0002f8  69b0              LDR      r0,[r6,#0x18]         ;161  ; Modify_B_ACT
0002fa  9005              STR      r0,[sp,#0x14]         ;161
0002fc  9805              LDR      r0,[sp,#0x14]         ;162
0002fe  68f1              LDR      r1,[r6,#0xc]          ;162  ; Modify_A_ACT
000300  1a40              SUBS     r0,r0,r1              ;162
000302  9005              STR      r0,[sp,#0x14]         ;162
000304  9805              LDR      r0,[sp,#0x14]         ;163
000306  0300              LSLS     r0,r0,#12             ;163
000308  9005              STR      r0,[sp,#0x14]         ;163
00030a  6930              LDR      r0,[r6,#0x10]         ;164  ; Modify_B_READ
00030c  6871              LDR      r1,[r6,#4]            ;164  ; Modify_A_READ
00030e  1a40              SUBS     r0,r0,r1              ;164
000310  9006              STR      r0,[sp,#0x18]         ;164
000312  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;165
000316  fbb0f0f1          UDIV     r0,r0,r1              ;165
00031a  9005              STR      r0,[sp,#0x14]         ;165
00031c  9805              LDR      r0,[sp,#0x14]         ;166
00031e  f8c80000          STR      r0,[r8,#0]            ;166  ; Correct_Parametet
000322  69b0              LDR      r0,[r6,#0x18]         ;168  ; Modify_B_ACT
000324  9005              STR      r0,[sp,#0x14]         ;168
000326  9805              LDR      r0,[sp,#0x14]         ;169
000328  0300              LSLS     r0,r0,#12             ;169
00032a  9005              STR      r0,[sp,#0x14]         ;169
00032c  6930              LDR      r0,[r6,#0x10]         ;170  ; Modify_B_READ
00032e  9004              STR      r0,[sp,#0x10]         ;170
000330  f8d80000          LDR      r0,[r8,#0]            ;171  ; Correct_Parametet
000334  9904              LDR      r1,[sp,#0x10]         ;171
000336  4348              MULS     r0,r1,r0              ;171
000338  9004              STR      r0,[sp,#0x10]         ;171
00033a  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;172
00033e  4288              CMP      r0,r1                 ;172
000340  d20a              BCS      |L3.856|
000342  e9dd0104          LDRD     r0,r1,[sp,#0x10]      ;174
000346  1a40              SUBS     r0,r0,r1              ;174
000348  9004              STR      r0,[sp,#0x10]         ;174
00034a  9804              LDR      r0,[sp,#0x10]         ;175
00034c  6028              STR      r0,[r5,#0]            ;175  ; Correct_Strong
00034e  7820              LDRB     r0,[r4,#0]            ;176  ; correct_por
000350  f0400001          ORR      r0,r0,#1              ;176
000354  7020              STRB     r0,[r4,#0]            ;176
000356  e009              B        |L3.876|
                  |L3.856|
000358  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;180
00035c  1a40              SUBS     r0,r0,r1              ;180
00035e  9005              STR      r0,[sp,#0x14]         ;180
000360  9805              LDR      r0,[sp,#0x14]         ;181
000362  6028              STR      r0,[r5,#0]            ;181  ; Correct_Strong
000364  7820              LDRB     r0,[r4,#0]            ;182  ; correct_por
000366  f0200001          BIC      r0,r0,#1              ;182
00036a  7020              STRB     r0,[r4,#0]            ;182
                  |L3.876|
00036c  f7fffffe          BL       Flash_Write_all
000370  6838              LDR      r0,[r7,#0]  ; flagB
000372  f0200008          BIC      r0,r0,#8
000376  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.888|
;;;186    		}
;;;187    		
;;;188    		
;;;189    /************************************负载电流测量和控制校准*****************************************************************/
;;;190    		if (UART_Buffer_Rece[1] == 0x03)			   //CC模式校准
000378  f89a2001          LDRB     r2,[r10,#1]  ; UART_Buffer_Rece
00037c  4650              MOV      r0,r10
;;;191    		{
;;;192    			Modify_A_READ = Imon1_value;//
00037e  4929              LDR      r1,|L3.1060|
;;;193    			Modify_C_READ = Contr_Laod;//
000380  f8dfa0a4          LDR      r10,|L3.1064|
000384  2a03              CMP      r2,#3                 ;190
000386  d10f              BNE      |L3.936|
000388  680a              LDR      r2,[r1,#0]            ;192  ; Imon1_value
00038a  6072              STR      r2,[r6,#4]            ;192  ; Modify_A_READ
00038c  f8ba2000          LDRH     r2,[r10,#0]  ; Contr_Laod
000390  60b2              STR      r2,[r6,#8]  ; Modify_C_READ
;;;194    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000392  7902              LDRB     r2,[r0,#4]  ; UART_Buffer_Rece
000394  78c3              LDRB     r3,[r0,#3]  ; UART_Buffer_Rece
000396  eb022203          ADD      r2,r2,r3,LSL #8
00039a  e000              B        |L3.926|
                  |L3.924|
00039c  e3b5              B        |L3.2826|
                  |L3.926|
00039e  60f2              STR      r2,[r6,#0xc]  ; Modify_A_ACT
;;;195    			Flag_DAC_OFF=1;//
0003a0  683a              LDR      r2,[r7,#0]  ; flagB
0003a2  f0420208          ORR      r2,r2,#8
0003a6  603a              STR      r2,[r7,#0]  ; flagB
                  |L3.936|
;;;196    		}
;;;197    
;;;198    		if (UART_Buffer_Rece[1] == 0x04)			   //
0003a8  4815              LDR      r0,|L3.1024|
0003aa  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
0003ac  2804              CMP      r0,#4
0003ae  d17d              BNE      |L3.1196|
;;;199    		{
;;;200    			vu32 var16;
;;;201    			vu32 var32a;
;;;202    			vu32 var32b;
;;;203    			
;;;204    			vu32 var16a;
;;;205    			vu32 var32c;
;;;206    			vu32 var32d;
;;;207    			
;;;208    			Modify_B_READ = Imon1_value;
0003b0  6808              LDR      r0,[r1,#0]  ; Imon1_value
0003b2  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;209    			Modify_D_READ = Contr_Laod;
0003b4  f8ba0000          LDRH     r0,[r10,#0]  ; Contr_Laod
0003b8  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;210    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0003ba  4811              LDR      r0,|L3.1024|
0003bc  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
0003be  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
0003c0  eb012000          ADD      r0,r1,r0,LSL #8
0003c4  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;211    			
;;;212    			var32a = Modify_B_ACT;
0003c6  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0003c8  9005              STR      r0,[sp,#0x14]
;;;213    			var32a = var32a - Modify_A_ACT;
0003ca  9805              LDR      r0,[sp,#0x14]
0003cc  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0003ce  1a40              SUBS     r0,r0,r1
0003d0  9005              STR      r0,[sp,#0x14]
;;;214    			var32a = var32a << 12;
0003d2  9805              LDR      r0,[sp,#0x14]
0003d4  0300              LSLS     r0,r0,#12
0003d6  9005              STR      r0,[sp,#0x14]
;;;215    			var16 = Modify_B_READ - Modify_A_READ;
0003d8  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0003da  6871              LDR      r1,[r6,#4]  ; Modify_A_READ
0003dc  1a40              SUBS     r0,r0,r1
0003de  9006              STR      r0,[sp,#0x18]
;;;216    			var32a = var32a / var16;
0003e0  e9dd0105          LDRD     r0,r1,[sp,#0x14]
0003e4  fbb0f0f1          UDIV     r0,r0,r1
0003e8  9005              STR      r0,[sp,#0x14]
;;;217    			REG_Load_A = var32a;
0003ea  9805              LDR      r0,[sp,#0x14]
0003ec  f8c80004          STR      r0,[r8,#4]  ; Correct_Parametet
;;;218    			var32a = Modify_B_ACT;
0003f0  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0003f2  9005              STR      r0,[sp,#0x14]
;;;219    			var32a = var32a << 12;
0003f4  9805              LDR      r0,[sp,#0x14]
0003f6  0300              LSLS     r0,r0,#12
0003f8  9005              STR      r0,[sp,#0x14]
;;;220    			var32b = Modify_B_READ;
0003fa  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0003fc  9004              STR      r0,[sp,#0x10]
;;;221    			var32b = var32b * REG_Load_A;
0003fe  e015              B        |L3.1068|
                  |L3.1024|
                          DCD      UART_Buffer_Rece
                  |L3.1028|
                          DCD      ||area_number.8||
                  |L3.1032|
                          DCD      UART_Buffer_Send
                  |L3.1036|
                          DCD      Transmit_BUFFERsize
                  |L3.1040|
                          DCD      flagA
                  |L3.1044|
                          DCD      ||.bss||+0x58
                  |L3.1048|
                          DCD      flagF
                  |L3.1052|
                          DCD      Vmon1_value
                  |L3.1056|
                          DCD      flagB
                  |L3.1060|
                          DCD      Imon1_value
                  |L3.1064|
                          DCD      Contr_Laod
                  |L3.1068|
00042c  f8d80004          LDR      r0,[r8,#4]  ; Correct_Parametet
000430  9904              LDR      r1,[sp,#0x10]
000432  4348              MULS     r0,r1,r0
000434  9004              STR      r0,[sp,#0x10]
;;;222    			if (var32a < var32b)
000436  e9dd0104          LDRD     r0,r1,[sp,#0x10]
00043a  4281              CMP      r1,r0
00043c  d20a              BCS      |L3.1108|
;;;223    			{
;;;224    				var32b = var32b - var32a;
00043e  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000442  1a40              SUBS     r0,r0,r1
000444  9004              STR      r0,[sp,#0x10]
;;;225    				REG_LoadA_Offset = var32b;
000446  9804              LDR      r0,[sp,#0x10]
000448  6068              STR      r0,[r5,#4]  ; Correct_Strong
;;;226    				Polar1 |= 0x01;
00044a  7860              LDRB     r0,[r4,#1]  ; correct_por
00044c  f0400001          ORR      r0,r0,#1
000450  7060              STRB     r0,[r4,#1]
000452  e009              B        |L3.1128|
                  |L3.1108|
;;;227    			}
;;;228    			else 
;;;229    			{
;;;230    				var32a = var32a - var32b;
000454  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000458  1a08              SUBS     r0,r1,r0
00045a  9005              STR      r0,[sp,#0x14]
;;;231    				REG_LoadA_Offset = var32a;
00045c  9805              LDR      r0,[sp,#0x14]
00045e  6068              STR      r0,[r5,#4]  ; Correct_Strong
;;;232    				Polar1 &= ~0x01;					
000460  7860              LDRB     r0,[r4,#1]  ; correct_por
000462  f0200001          BIC      r0,r0,#1
000466  7060              STRB     r0,[r4,#1]
                  |L3.1128|
;;;233    			}
;;;234    //---------------------------------------------------------------------------------//
;;;235    			var32c = Modify_B_ACT; 
000468  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
00046a  9002              STR      r0,[sp,#8]
;;;236    			var32c = var32c - Modify_A_ACT;
00046c  9802              LDR      r0,[sp,#8]
00046e  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
000470  1a40              SUBS     r0,r0,r1
000472  9002              STR      r0,[sp,#8]
;;;237    			var32c = var32c << 12;
000474  9802              LDR      r0,[sp,#8]
000476  0300              LSLS     r0,r0,#12
000478  9002              STR      r0,[sp,#8]
;;;238    			var16a=Modify_D_READ-Modify_C_READ;
00047a  6970              LDR      r0,[r6,#0x14]  ; Modify_D_READ
00047c  68b1              LDR      r1,[r6,#8]  ; Modify_C_READ
00047e  1a40              SUBS     r0,r0,r1
000480  9003              STR      r0,[sp,#0xc]
;;;239    			var16a=var16a*2;
000482  9803              LDR      r0,[sp,#0xc]
000484  0040              LSLS     r0,r0,#1
000486  9003              STR      r0,[sp,#0xc]
;;;240    			var32c=var32c/var16a;
000488  e9dd1002          LDRD     r1,r0,[sp,#8]
00048c  fbb1f0f0          UDIV     r0,r1,r0
000490  9002              STR      r0,[sp,#8]
;;;241    			SET_LoadA = var32c;
000492  9802              LDR      r0,[sp,#8]
000494  f8c80008          STR      r0,[r8,#8]  ; Correct_Parametet
;;;242    			var32c = Modify_B_ACT;
000498  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
00049a  9002              STR      r0,[sp,#8]
;;;243    			var32c = var32c << 12;
00049c  9802              LDR      r0,[sp,#8]
00049e  0300              LSLS     r0,r0,#12
0004a0  9002              STR      r0,[sp,#8]
;;;244    			var32d = SET_LoadA;
0004a2  f8d80008          LDR      r0,[r8,#8]  ; Correct_Parametet
0004a6  9001              STR      r0,[sp,#4]
;;;245    			var32d = var32d * (Modify_D_READ*2);
0004a8  9801              LDR      r0,[sp,#4]
0004aa  e000              B        |L3.1198|
                  |L3.1196|
0004ac  e022              B        |L3.1268|
                  |L3.1198|
0004ae  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
0004b0  4348              MULS     r0,r1,r0
0004b2  0040              LSLS     r0,r0,#1
0004b4  9001              STR      r0,[sp,#4]
;;;246    			if (var32c < var32d)
0004b6  e9dd1001          LDRD     r1,r0,[sp,#4]
0004ba  4288              CMP      r0,r1
0004bc  d20a              BCS      |L3.1236|
;;;247    			{
;;;248    				var32d = var32d - var32c;
0004be  e9dd0101          LDRD     r0,r1,[sp,#4]
0004c2  1a40              SUBS     r0,r0,r1
0004c4  9001              STR      r0,[sp,#4]
;;;249    				SET_LoadA_Offset = var32d;
0004c6  9801              LDR      r0,[sp,#4]
0004c8  60a8              STR      r0,[r5,#8]  ; Correct_Strong
;;;250    				Polar1 |= 0x04;
0004ca  7860              LDRB     r0,[r4,#1]  ; correct_por
0004cc  f0400004          ORR      r0,r0,#4
0004d0  7060              STRB     r0,[r4,#1]
0004d2  e009              B        |L3.1256|
                  |L3.1236|
;;;251    			}
;;;252    			else 
;;;253    			{
;;;254    				var32c = var32c - var32d;
0004d4  e9dd1001          LDRD     r1,r0,[sp,#4]
0004d8  1a40              SUBS     r0,r0,r1
0004da  9002              STR      r0,[sp,#8]
;;;255    				SET_LoadA_Offset = var32c;
0004dc  9802              LDR      r0,[sp,#8]
0004de  60a8              STR      r0,[r5,#8]  ; Correct_Strong
;;;256    				Polar1 &= ~0x04;
0004e0  7860              LDRB     r0,[r4,#1]  ; correct_por
0004e2  f0200004          BIC      r0,r0,#4
0004e6  7060              STRB     r0,[r4,#1]
                  |L3.1256|
;;;257    			}
;;;258    			Flash_Write_all ();	
0004e8  f7fffffe          BL       Flash_Write_all
;;;259    			Flag_DAC_OFF =0;
0004ec  6838              LDR      r0,[r7,#0]  ; flagB
0004ee  f0200008          BIC      r0,r0,#8
0004f2  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1268|
;;;260    		}
;;;261    /*************************************负载CV模式电压控制校准**************************************************************/
;;;262    		if(UART_Buffer_Rece[1] == 0x05)
0004f4  48fe              LDR      r0,|L3.2288|
0004f6  7841              LDRB     r1,[r0,#1]  ; UART_Buffer_Rece
0004f8  2905              CMP      r1,#5
0004fa  d10a              BNE      |L3.1298|
;;;263    		{
;;;264    			Modify_A_READ = Vmon1_value;//测量电压值
0004fc  f8db1000          LDR      r1,[r11,#0]  ; Vmon1_value
000500  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;265    			Modify_C_READ = Contr_Laod;//设置电压值
000502  f8ba1000          LDRH     r1,[r10,#0]  ; Contr_Laod
000506  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;266    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
000508  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
00050a  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
00050c  eb012102          ADD      r1,r1,r2,LSL #8
000510  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1298|
;;;267    		}
;;;268    		if (UART_Buffer_Rece[1] == 0x06)			   //电压测量校准完成
000512  48f7              LDR      r0,|L3.2288|
000514  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
000516  2806              CMP      r0,#6
000518  d17b              BNE      |L3.1554|
;;;269    		{
;;;270    			vu32 var16;
;;;271    			vu32 var32a;
;;;272    			vu32 var32b;
;;;273    			
;;;274    			vu32 var16a;
;;;275    			vu32 var32c;
;;;276    			vu32 var32d;
;;;277    			
;;;278    			Modify_B_READ =Vmon1_value;//测量电压值
00051a  f8db0000          LDR      r0,[r11,#0]  ; Vmon1_value
00051e  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;279    			Modify_D_READ =Contr_Laod;//设置电压值
000520  f8ba0000          LDRH     r0,[r10,#0]  ; Contr_Laod
000524  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;280    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000526  48f2              LDR      r0,|L3.2288|
000528  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
00052a  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
00052c  eb012000          ADD      r0,r1,r0,LSL #8
000530  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;281    			var32a = Modify_B_ACT;
000532  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000534  9005              STR      r0,[sp,#0x14]
;;;282    			var32a = var32a - Modify_A_ACT;
000536  9805              LDR      r0,[sp,#0x14]
000538  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00053a  1a40              SUBS     r0,r0,r1
00053c  9005              STR      r0,[sp,#0x14]
;;;283    			var32a = var32a << 12;
00053e  9805              LDR      r0,[sp,#0x14]
000540  0300              LSLS     r0,r0,#12
000542  9005              STR      r0,[sp,#0x14]
;;;284    			var16 = Modify_B_READ - Modify_A_READ;
000544  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000546  6871              LDR      r1,[r6,#4]  ; Modify_A_READ
000548  1a40              SUBS     r0,r0,r1
00054a  9006              STR      r0,[sp,#0x18]
;;;285    			var32a = var32a / var16;
00054c  e9dd0105          LDRD     r0,r1,[sp,#0x14]
000550  fbb0f0f1          UDIV     r0,r0,r1
000554  9005              STR      r0,[sp,#0x14]
;;;286    			REG_LoadV = var32a;
000556  9805              LDR      r0,[sp,#0x14]
000558  f8c8000c          STR      r0,[r8,#0xc]  ; Correct_Parametet
;;;287    			var32a=0;
00055c  f04f0b00          MOV      r11,#0
;;;288    			var32a = Modify_B_ACT;
000560  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000562  9005              STR      r0,[sp,#0x14]
;;;289    			var32a = var32a << 12;
000564  9805              LDR      r0,[sp,#0x14]
000566  0300              LSLS     r0,r0,#12
000568  9005              STR      r0,[sp,#0x14]
;;;290    			var32b = Modify_B_READ;
00056a  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
00056c  9004              STR      r0,[sp,#0x10]
;;;291    			var32b = var32b * REG_LoadV;
00056e  f8d8000c          LDR      r0,[r8,#0xc]  ; Correct_Parametet
000572  9904              LDR      r1,[sp,#0x10]
000574  4348              MULS     r0,r1,r0
000576  9004              STR      r0,[sp,#0x10]
;;;292    			if (var32a < var32b)
000578  e9dd1004          LDRD     r1,r0,[sp,#0x10]
00057c  4288              CMP      r0,r1
00057e  d20a              BCS      |L3.1430|
;;;293    			{
;;;294    				var32b = var32b - var32a;
000580  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000584  1a40              SUBS     r0,r0,r1
000586  9004              STR      r0,[sp,#0x10]
;;;295    				REG_LoadV_Offset = var32b;
000588  9804              LDR      r0,[sp,#0x10]
00058a  60e8              STR      r0,[r5,#0xc]  ; Correct_Strong
;;;296    				Polar2 |= 0x01;
00058c  78a0              LDRB     r0,[r4,#2]  ; correct_por
00058e  f0400001          ORR      r0,r0,#1
000592  70a0              STRB     r0,[r4,#2]
000594  e009              B        |L3.1450|
                  |L3.1430|
;;;297    			}
;;;298    			else 
;;;299    			{
;;;300    				var32a = var32a - var32b;
000596  e9dd1004          LDRD     r1,r0,[sp,#0x10]
00059a  1a40              SUBS     r0,r0,r1
00059c  9005              STR      r0,[sp,#0x14]
;;;301    				REG_LoadV_Offset = var32a;
00059e  9805              LDR      r0,[sp,#0x14]
0005a0  60e8              STR      r0,[r5,#0xc]  ; Correct_Strong
;;;302    				Polar2 &= ~0x01;
0005a2  78a0              LDRB     r0,[r4,#2]  ; correct_por
0005a4  f0200001          BIC      r0,r0,#1
0005a8  70a0              STRB     r0,[r4,#2]
                  |L3.1450|
;;;303    			}
;;;304    //---------------------------------------------------------------------------------------//			
;;;305    			var32c = Modify_B_ACT; //CV模式电压控制校准
0005aa  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0005ac  9002              STR      r0,[sp,#8]
;;;306    			var32c = var32c - Modify_A_ACT;
0005ae  9802              LDR      r0,[sp,#8]
0005b0  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0005b2  1a40              SUBS     r0,r0,r1
0005b4  9002              STR      r0,[sp,#8]
;;;307    			var32c = var32c << 12;
0005b6  9802              LDR      r0,[sp,#8]
0005b8  0300              LSLS     r0,r0,#12
0005ba  9002              STR      r0,[sp,#8]
;;;308    			var16a=Modify_D_READ-Modify_C_READ;
0005bc  6970              LDR      r0,[r6,#0x14]  ; Modify_D_READ
0005be  68b1              LDR      r1,[r6,#8]  ; Modify_C_READ
0005c0  1a40              SUBS     r0,r0,r1
0005c2  9003              STR      r0,[sp,#0xc]
;;;309    			var16a=(var16a*2);
0005c4  9803              LDR      r0,[sp,#0xc]
0005c6  0040              LSLS     r0,r0,#1
0005c8  9003              STR      r0,[sp,#0xc]
;;;310    			var32c=var32c/var16a;
0005ca  e9dd0102          LDRD     r0,r1,[sp,#8]
0005ce  fbb0f0f1          UDIV     r0,r0,r1
0005d2  9002              STR      r0,[sp,#8]
;;;311    			SET_LoadV = var32c;
0005d4  9802              LDR      r0,[sp,#8]
0005d6  f8c80010          STR      r0,[r8,#0x10]  ; Correct_Parametet
;;;312    			var32c = Modify_B_ACT;
0005da  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0005dc  9002              STR      r0,[sp,#8]
;;;313    			var32c = var32c << 12;
0005de  9802              LDR      r0,[sp,#8]
0005e0  0300              LSLS     r0,r0,#12
0005e2  9002              STR      r0,[sp,#8]
;;;314    			var32d = SET_LoadV;
0005e4  f8d80010          LDR      r0,[r8,#0x10]  ; Correct_Parametet
0005e8  9001              STR      r0,[sp,#4]
;;;315    			var32d = var32d * (Modify_D_READ*2);
0005ea  9801              LDR      r0,[sp,#4]
0005ec  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
0005ee  4348              MULS     r0,r1,r0
0005f0  0040              LSLS     r0,r0,#1
0005f2  9001              STR      r0,[sp,#4]
;;;316    			if (var32c < var32d)
0005f4  e9dd1001          LDRD     r1,r0,[sp,#4]
0005f8  4288              CMP      r0,r1
0005fa  d20b              BCS      |L3.1556|
;;;317    			{
;;;318    				var32d = var32d - var32c;
0005fc  e9dd0101          LDRD     r0,r1,[sp,#4]
000600  1a40              SUBS     r0,r0,r1
000602  9001              STR      r0,[sp,#4]
;;;319    				SET_LoadV_Offset = var32d;
000604  9801              LDR      r0,[sp,#4]
000606  6128              STR      r0,[r5,#0x10]  ; Correct_Strong
;;;320    				Polar2 |= 0x04;
000608  78a0              LDRB     r0,[r4,#2]  ; correct_por
00060a  f0400004          ORR      r0,r0,#4
00060e  70a0              STRB     r0,[r4,#2]
000610  e00a              B        |L3.1576|
                  |L3.1554|
000612  e00d              B        |L3.1584|
                  |L3.1556|
;;;321    			}
;;;322    			else 
;;;323    			{
;;;324    				var32c = var32c - var32d;
000614  e9dd1001          LDRD     r1,r0,[sp,#4]
000618  1a40              SUBS     r0,r0,r1
00061a  9002              STR      r0,[sp,#8]
;;;325    				SET_LoadV_Offset = var32c;
00061c  9802              LDR      r0,[sp,#8]
00061e  6128              STR      r0,[r5,#0x10]  ; Correct_Strong
;;;326    				Polar2 &= ~0x04;
000620  78a0              LDRB     r0,[r4,#2]  ; correct_por
000622  f0200004          BIC      r0,r0,#4
000626  70a0              STRB     r0,[r4,#2]
                  |L3.1576|
;;;327    			}
;;;328    //---------------------------------------------------------------------------------------//
;;;329    		  Flash_Write_all();	//参数写进FLASH
000628  f7fffffe          BL       Flash_Write_all
;;;330    			DAC_Flag=0;
00062c  f886b000          STRB     r11,[r6,#0]
                  |L3.1584|
;;;331    		}
;;;332    /*************************************内阻校准**************************************************************************/
;;;333    		if(UART_Buffer_Rece[1] == 0x07||flag_ADJ_VL==1)
000630  f8dfb2bc          LDR      r11,|L3.2288|
000634  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
;;;334    		{
;;;335    			Modify_A_READ = Rmon_value;//测量电压值
000638  48ae              LDR      r0,|L3.2292|
00063a  2907              CMP      r1,#7                 ;333
00063c  d003              BEQ      |L3.1606|
00063e  f8991000          LDRB     r1,[r9,#0]            ;333  ; flagF
000642  0749              LSLS     r1,r1,#29             ;333
000644  d508              BPL      |L3.1624|
                  |L3.1606|
000646  8801              LDRH     r1,[r0,#0]  ; Rmon_value
000648  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;336    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取低段
00064a  f89b1004          LDRB     r1,[r11,#4]  ; UART_Buffer_Rece
00064e  f89b2003          LDRB     r2,[r11,#3]  ; UART_Buffer_Rece
000652  eb012102          ADD      r1,r1,r2,LSL #8
000656  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1624|
;;;337    		}
;;;338    		if (UART_Buffer_Rece[1] == 0x08||flag_ADJ_VH==1)			   //电压测量校准完成
000658  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
00065c  2908              CMP      r1,#8
00065e  d003              BEQ      |L3.1640|
000660  f8991000          LDRB     r1,[r9,#0]  ; flagF
000664  0709              LSLS     r1,r1,#28
000666  d55b              BPL      |L3.1824|
                  |L3.1640|
;;;339    		{
;;;340    			vu16 var16;
;;;341    			vu32 var32a;
;;;342    			vu32 var32b;
;;;343    			
;;;344    			vu16 var16a;
;;;345    			vu32 var32c;
;;;346    			vu32 var32d;
;;;347    			Modify_B_READ =Rmon_value;//测量电压值
000668  8800              LDRH     r0,[r0,#0]  ; Rmon_value
00066a  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;348    			flag_OverV=1;
00066c  49a2              LDR      r1,|L3.2296|
00066e  6808              LDR      r0,[r1,#0]  ; flagG
000670  f0400002          ORR      r0,r0,#2
000674  6008              STR      r0,[r1,#0]  ; flagG
;;;349    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];//读取高段
000676  f89b1004          LDRB     r1,[r11,#4]  ; UART_Buffer_Rece
00067a  f89b2003          LDRB     r2,[r11,#3]  ; UART_Buffer_Rece
00067e  eb012102          ADD      r1,r1,r2,LSL #8
000682  61b1              STR      r1,[r6,#0x18]  ; Modify_B_ACT
;;;350    			if(flag_OverV==1)//只有当有数据写入时才能将校准数据写入FLASH
000684  0780              LSLS     r0,r0,#30
000686  d545              BPL      |L3.1812|
;;;351    			{
;;;352    				var32a = Modify_B_ACT;
000688  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
00068a  9005              STR      r0,[sp,#0x14]
;;;353    				var32a = var32a - Modify_A_ACT;
00068c  9805              LDR      r0,[sp,#0x14]
00068e  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
000690  1a40              SUBS     r0,r0,r1
000692  9005              STR      r0,[sp,#0x14]
;;;354    				var32a = var32a << 12;
000694  9805              LDR      r0,[sp,#0x14]
000696  0300              LSLS     r0,r0,#12
000698  9005              STR      r0,[sp,#0x14]
;;;355    				var16 = Modify_B_READ - Modify_A_READ;
00069a  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
00069c  6871              LDR      r1,[r6,#4]  ; Modify_A_READ
00069e  1a40              SUBS     r0,r0,r1
0006a0  9006              STR      r0,[sp,#0x18]
;;;356    				var32a = var32a / var16;
0006a2  f8bd1018          LDRH     r1,[sp,#0x18]
0006a6  9805              LDR      r0,[sp,#0x14]
0006a8  fbb0f0f1          UDIV     r0,r0,r1
0006ac  9005              STR      r0,[sp,#0x14]
;;;357    				REG_CorrectionR = var32a;
0006ae  9805              LDR      r0,[sp,#0x14]
0006b0  f8c80014          STR      r0,[r8,#0x14]  ; Correct_Parametet
;;;358    				var32a=0;
;;;359    				var32a = Modify_B_ACT;
0006b4  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0006b6  9005              STR      r0,[sp,#0x14]
;;;360    				var32a = var32a << 12;
0006b8  9805              LDR      r0,[sp,#0x14]
0006ba  0300              LSLS     r0,r0,#12
0006bc  9005              STR      r0,[sp,#0x14]
;;;361    				var32b = Modify_B_READ;
0006be  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0006c0  9004              STR      r0,[sp,#0x10]
;;;362    				var32b = var32b * REG_CorrectionR;
0006c2  f8d80014          LDR      r0,[r8,#0x14]  ; Correct_Parametet
0006c6  9904              LDR      r1,[sp,#0x10]
0006c8  4348              MULS     r0,r1,r0
0006ca  9004              STR      r0,[sp,#0x10]
;;;363    				if (var32a < var32b)
0006cc  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0006d0  4288              CMP      r0,r1
0006d2  d20a              BCS      |L3.1770|
;;;364    				{
;;;365    					var32b = var32b - var32a;
0006d4  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0006d8  1a40              SUBS     r0,r0,r1
0006da  9004              STR      r0,[sp,#0x10]
;;;366    					REG_ReadR_Offset = var32b;
0006dc  9804              LDR      r0,[sp,#0x10]
0006de  6168              STR      r0,[r5,#0x14]  ; Correct_Strong
;;;367    					Polar3 |= 0x01;
0006e0  78e0              LDRB     r0,[r4,#3]  ; correct_por
0006e2  f0400001          ORR      r0,r0,#1
0006e6  70e0              STRB     r0,[r4,#3]
0006e8  e009              B        |L3.1790|
                  |L3.1770|
;;;368    				}
;;;369    				else 
;;;370    				{
;;;371    					var32a = var32a - var32b;
0006ea  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0006ee  1a40              SUBS     r0,r0,r1
0006f0  9005              STR      r0,[sp,#0x14]
;;;372    					REG_ReadR_Offset = var32a;
0006f2  9805              LDR      r0,[sp,#0x14]
0006f4  6168              STR      r0,[r5,#0x14]  ; Correct_Strong
;;;373    					Polar3 &= ~0x01;
0006f6  78e0              LDRB     r0,[r4,#3]  ; correct_por
0006f8  f0200001          BIC      r0,r0,#1
0006fc  70e0              STRB     r0,[r4,#3]
                  |L3.1790|
;;;374    				}
;;;375    	//---------------------------------------------------------------------------------------//
;;;376    				Flash_Write_all();	//参数写进FLASH
0006fe  f7fffffe          BL       Flash_Write_all
;;;377    				flag_OverV=0;
000702  487d              LDR      r0,|L3.2296|
000704  6801              LDR      r1,[r0,#0]  ; flagG
000706  f0210102          BIC      r1,r1,#2
00070a  6001              STR      r1,[r0,#0]  ; flagG
;;;378    				Flag_DAC_OFF=0;
00070c  6838              LDR      r0,[r7,#0]  ; flagB
00070e  f0200008          BIC      r0,r0,#8
000712  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.1812|
;;;379    			}
;;;380    			flag_ADJ_VH=0;//清掉标志位防止一直进入
000714  f8d90000          LDR      r0,[r9,#0]  ; flagF
000718  f0200008          BIC      r0,r0,#8
00071c  f8c90000          STR      r0,[r9,#0]  ; flagF
                  |L3.1824|
;;;381    		}		
;;;382    /*******************************电源CC模式电流测量和控制校准******************************************/	
;;;383    		if (UART_Buffer_Rece[1] == 0x09||flag_ADJ_ALCC==1)			   //电流测量校准
000720  f89b1001          LDRB     r1,[r11,#1]  ; UART_Buffer_Rece
000724  4658              MOV      r0,r11
;;;384    		{
;;;385    			Modify_A_READ = Imon_value;//测量电流
000726  f8dfb1d4          LDR      r11,|L3.2300|
00072a  2909              CMP      r1,#9                 ;383
00072c  d003              BEQ      |L3.1846|
00072e  f8991000          LDRB     r1,[r9,#0]            ;383  ; flagF
000732  06c9              LSLS     r1,r1,#27             ;383
000734  d50a              BPL      |L3.1868|
                  |L3.1846|
000736  f8bb1000          LDRH     r1,[r11,#0]  ; Imon_value
00073a  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;386    			Modify_C_READ = Contr_Current;//设置电流
00073c  4970              LDR      r1,|L3.2304|
00073e  8809              LDRH     r1,[r1,#0]  ; Contr_Current
000740  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;387    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000742  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
000744  78c2              LDRB     r2,[r0,#3]  ; UART_Buffer_Rece
000746  eb012102          ADD      r1,r1,r2,LSL #8
00074a  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.1868|
;;;388    		}
;;;389    
;;;390    		if (UART_Buffer_Rece[1] == 0x0A||flag_ADJ_AHCC==1)			   //电流测量校准完成
00074c  4868              LDR      r0,|L3.2288|
00074e  7840              LDRB     r0,[r0,#1]  ; UART_Buffer_Rece
000750  280a              CMP      r0,#0xa
000752  d003              BEQ      |L3.1884|
000754  f8990000          LDRB     r0,[r9,#0]  ; flagF
000758  0680              LSLS     r0,r0,#26
00075a  d57c              BPL      |L3.2134|
                  |L3.1884|
;;;391    		{
;;;392    			vu16 var16;
;;;393    			vu32 var32a;
;;;394    			vu32 var32b;
;;;395    			
;;;396    			vu16 var16a;
;;;397    			vu32 var32c;
;;;398    			vu32 var32d;
;;;399    			
;;;400    			Modify_D_READ = Contr_Current;
00075c  4868              LDR      r0,|L3.2304|
00075e  8800              LDRH     r0,[r0,#0]  ; Contr_Current
000760  6170              STR      r0,[r6,#0x14]  ; Modify_D_READ
;;;401    			Modify_B_READ = Imon_value;
000762  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
000766  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;402    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000768  4861              LDR      r0,|L3.2288|
00076a  7901              LDRB     r1,[r0,#4]  ; UART_Buffer_Rece
00076c  78c0              LDRB     r0,[r0,#3]  ; UART_Buffer_Rece
00076e  eb012000          ADD      r0,r1,r0,LSL #8
000772  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;403    			var32a = Modify_B_ACT;
000774  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000776  9005              STR      r0,[sp,#0x14]
;;;404    			var32a = var32a - Modify_A_ACT;
000778  9805              LDR      r0,[sp,#0x14]
00077a  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
00077c  1a40              SUBS     r0,r0,r1
00077e  9005              STR      r0,[sp,#0x14]
;;;405    			var32a = var32a << 14;
000780  9805              LDR      r0,[sp,#0x14]
000782  0380              LSLS     r0,r0,#14
000784  9005              STR      r0,[sp,#0x14]
;;;406    			var16 = Modify_B_READ - Modify_A_READ;
000786  6931              LDR      r1,[r6,#0x10]  ; Modify_B_READ
000788  6870              LDR      r0,[r6,#4]  ; Modify_A_READ
00078a  1a08              SUBS     r0,r1,r0
00078c  9006              STR      r0,[sp,#0x18]
;;;407    			var32a = var32a / var16;
00078e  f8bd1018          LDRH     r1,[sp,#0x18]
000792  9805              LDR      r0,[sp,#0x14]
000794  fbb0f0f1          UDIV     r0,r0,r1
000798  9005              STR      r0,[sp,#0x14]
;;;408    			REG_POWERA = var32a;
00079a  9805              LDR      r0,[sp,#0x14]
00079c  f8c80018          STR      r0,[r8,#0x18]  ; Correct_Parametet
;;;409    			var32a = Modify_B_ACT;
0007a0  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0007a2  9005              STR      r0,[sp,#0x14]
;;;410    			var32a = var32a << 14;
0007a4  9805              LDR      r0,[sp,#0x14]
0007a6  0380              LSLS     r0,r0,#14
0007a8  9005              STR      r0,[sp,#0x14]
;;;411    			var32b = Modify_B_READ;
0007aa  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0007ac  9004              STR      r0,[sp,#0x10]
;;;412    			var32b = var32b * REG_POWERA;
0007ae  f8d80018          LDR      r0,[r8,#0x18]  ; Correct_Parametet
0007b2  9904              LDR      r1,[sp,#0x10]
0007b4  4348              MULS     r0,r1,r0
0007b6  9004              STR      r0,[sp,#0x10]
;;;413    			if (var32a < var32b)
0007b8  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0007bc  4288              CMP      r0,r1
0007be  d20a              BCS      |L3.2006|
;;;414    			{
;;;415    				var32b = var32b - var32a;
0007c0  e9dd0104          LDRD     r0,r1,[sp,#0x10]
0007c4  1a40              SUBS     r0,r0,r1
0007c6  9004              STR      r0,[sp,#0x10]
;;;416    				REG_POWERA_Offset = var32b;
0007c8  9804              LDR      r0,[sp,#0x10]
0007ca  61a8              STR      r0,[r5,#0x18]  ; Correct_Strong
;;;417    				Polar4 |= 0x01;
0007cc  7920              LDRB     r0,[r4,#4]  ; correct_por
0007ce  f0400001          ORR      r0,r0,#1
0007d2  7120              STRB     r0,[r4,#4]
0007d4  e009              B        |L3.2026|
                  |L3.2006|
;;;418    			}
;;;419    			else 
;;;420    			{
;;;421    				var32a = var32a - var32b;
0007d6  e9dd1004          LDRD     r1,r0,[sp,#0x10]
0007da  1a40              SUBS     r0,r0,r1
0007dc  9005              STR      r0,[sp,#0x14]
;;;422    				REG_POWERA_Offset = var32a;
0007de  9805              LDR      r0,[sp,#0x14]
0007e0  61a8              STR      r0,[r5,#0x18]  ; Correct_Strong
;;;423    				Polar4 &= ~0x01;					//电流测量系数和零点校准完成
0007e2  7920              LDRB     r0,[r4,#4]  ; correct_por
0007e4  f0200001          BIC      r0,r0,#1
0007e8  7120              STRB     r0,[r4,#4]
                  |L3.2026|
;;;424    			}
;;;425    	//---------------------------------------------------------------------------------//
;;;426    			var32c = Modify_B_ACT; //设置电流校准
0007ea  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0007ec  9002              STR      r0,[sp,#8]
;;;427    			var32c = var32c - Modify_A_ACT;
0007ee  9802              LDR      r0,[sp,#8]
0007f0  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0007f2  1a40              SUBS     r0,r0,r1
0007f4  9002              STR      r0,[sp,#8]
;;;428    			var32c = var32c << 14;
0007f6  9802              LDR      r0,[sp,#8]
0007f8  0380              LSLS     r0,r0,#14
0007fa  9002              STR      r0,[sp,#8]
;;;429    			var16a=Modify_D_READ-Modify_C_READ;
0007fc  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
0007fe  68b0              LDR      r0,[r6,#8]  ; Modify_C_READ
000800  1a08              SUBS     r0,r1,r0
000802  9003              STR      r0,[sp,#0xc]
;;;430    			var16a=var16a*2;
000804  f8bd100c          LDRH     r1,[sp,#0xc]
000808  f64f70ff          MOV      r0,#0xffff
00080c  ea000041          AND      r0,r0,r1,LSL #1
000810  9003              STR      r0,[sp,#0xc]
;;;431    			var32c=var32c/var16a;
000812  f8bd100c          LDRH     r1,[sp,#0xc]
000816  9802              LDR      r0,[sp,#8]
000818  fbb0f0f1          UDIV     r0,r0,r1
00081c  9002              STR      r0,[sp,#8]
;;;432    			SET_POWERA = var32c;
00081e  9802              LDR      r0,[sp,#8]
000820  f8c8001c          STR      r0,[r8,#0x1c]  ; Correct_Parametet
;;;433    			var32c = Modify_B_ACT;
000824  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000826  9002              STR      r0,[sp,#8]
;;;434    			var32c = var32c << 14;
000828  9802              LDR      r0,[sp,#8]
00082a  0380              LSLS     r0,r0,#14
00082c  9002              STR      r0,[sp,#8]
;;;435    			var32d = SET_POWERA;
00082e  f8d8001c          LDR      r0,[r8,#0x1c]  ; Correct_Parametet
000832  9001              STR      r0,[sp,#4]
;;;436    			var32d = var32d * (Modify_D_READ*2);
000834  9801              LDR      r0,[sp,#4]
000836  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
000838  4348              MULS     r0,r1,r0
00083a  0040              LSLS     r0,r0,#1
00083c  9001              STR      r0,[sp,#4]
;;;437    			if (var32c < var32d)
00083e  e9dd1001          LDRD     r1,r0,[sp,#4]
000842  4288              CMP      r0,r1
000844  d20c              BCS      |L3.2144|
;;;438    			{
;;;439    				var32d = var32d - var32c;
000846  e9dd0101          LDRD     r0,r1,[sp,#4]
00084a  1a40              SUBS     r0,r0,r1
00084c  9001              STR      r0,[sp,#4]
;;;440    				SET_POWERA_Offset = var32d;
00084e  9801              LDR      r0,[sp,#4]
000850  61e8              STR      r0,[r5,#0x1c]  ; Correct_Strong
;;;441    				Polar4 |= 0x04;
000852  7920              LDRB     r0,[r4,#4]  ; correct_por
000854  e000              B        |L3.2136|
                  |L3.2134|
000856  e013              B        |L3.2176|
                  |L3.2136|
000858  f0400004          ORR      r0,r0,#4
00085c  7120              STRB     r0,[r4,#4]
00085e  e009              B        |L3.2164|
                  |L3.2144|
;;;442    			}
;;;443    			else 
;;;444    			{
;;;445    				var32c = var32c - var32d;
000860  e9dd1001          LDRD     r1,r0,[sp,#4]
000864  1a40              SUBS     r0,r0,r1
000866  9002              STR      r0,[sp,#8]
;;;446    				SET_POWERA_Offset = var32c;
000868  9802              LDR      r0,[sp,#8]
00086a  61e8              STR      r0,[r5,#0x1c]  ; Correct_Strong
;;;447    				Polar4 &= ~0x04;
00086c  7920              LDRB     r0,[r4,#4]  ; correct_por
00086e  f0200004          BIC      r0,r0,#4
000872  7120              STRB     r0,[r4,#4]
                  |L3.2164|
;;;448    			}
;;;449    			Flash_Write_all ();	
000874  f7fffffe          BL       Flash_Write_all
;;;450    			Flag_DAC_OFF=0;
000878  6838              LDR      r0,[r7,#0]  ; flagB
00087a  f0200008          BIC      r0,r0,#8
00087e  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2176|
;;;451    		}
;;;452    /*******************************电源电压控制和测量校准******************************************/	
;;;453    		if (UART_Buffer_Rece[1] == 0x0B)			   //电流测量校准
000880  f8df906c          LDR      r9,|L3.2288|
000884  f8991001          LDRB     r1,[r9,#1]  ; UART_Buffer_Rece
;;;454    		{
;;;455    			Modify_A_READ = Vmon_value;//测量电流
000888  481e              LDR      r0,|L3.2308|
00088a  290b              CMP      r1,#0xb               ;453
00088c  d10b              BNE      |L3.2214|
00088e  8801              LDRH     r1,[r0,#0]  ; Vmon_value
000890  6071              STR      r1,[r6,#4]  ; Modify_A_READ
;;;456    			Modify_C_READ = Contr_Voltage;//设置电流
000892  491d              LDR      r1,|L3.2312|
000894  8809              LDRH     r1,[r1,#0]  ; Contr_Voltage
000896  60b1              STR      r1,[r6,#8]  ; Modify_C_READ
;;;457    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000898  f8991004          LDRB     r1,[r9,#4]  ; UART_Buffer_Rece
00089c  f8992003          LDRB     r2,[r9,#3]  ; UART_Buffer_Rece
0008a0  eb012102          ADD      r1,r1,r2,LSL #8
0008a4  60f1              STR      r1,[r6,#0xc]  ; Modify_A_ACT
                  |L3.2214|
;;;458    		}
;;;459    
;;;460    		if (UART_Buffer_Rece[1] == 0x0C)			   //电流测量校准完成
0008a6  f8991001          LDRB     r1,[r9,#1]  ; UART_Buffer_Rece
0008aa  290c              CMP      r1,#0xc
0008ac  d17e              BNE      |L3.2476|
;;;461    		{
;;;462    			vu16 var16;
;;;463    			vu32 var32a;
;;;464    			vu32 var32b;
;;;465    			
;;;466    			vu16 var16a;
;;;467    			vu32 var32c;
;;;468    			vu32 var32d;
;;;469    			
;;;470    			Modify_D_READ = Contr_Voltage;
0008ae  4916              LDR      r1,|L3.2312|
0008b0  8809              LDRH     r1,[r1,#0]  ; Contr_Voltage
0008b2  6171              STR      r1,[r6,#0x14]  ; Modify_D_READ
;;;471    			Modify_B_READ = Vmon_value;
0008b4  8800              LDRH     r0,[r0,#0]  ; Vmon_value
0008b6  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;472    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0008b8  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
0008bc  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
0008c0  eb002001          ADD      r0,r0,r1,LSL #8
0008c4  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;473    			var32a = Modify_B_ACT;
0008c6  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
0008c8  9005              STR      r0,[sp,#0x14]
;;;474    			var32a = var32a - Modify_A_ACT;
0008ca  9805              LDR      r0,[sp,#0x14]
0008cc  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
0008ce  1a40              SUBS     r0,r0,r1
0008d0  9005              STR      r0,[sp,#0x14]
;;;475    			var32a = var32a << 14;
0008d2  9805              LDR      r0,[sp,#0x14]
0008d4  0380              LSLS     r0,r0,#14
0008d6  9005              STR      r0,[sp,#0x14]
;;;476    			var16 = Modify_B_READ - Modify_A_READ;
0008d8  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
0008da  6871              LDR      r1,[r6,#4]  ; Modify_A_READ
0008dc  1a40              SUBS     r0,r0,r1
0008de  9006              STR      r0,[sp,#0x18]
;;;477    			var32a = var32a / var16;
0008e0  f8bd1018          LDRH     r1,[sp,#0x18]
0008e4  9805              LDR      r0,[sp,#0x14]
0008e6  fbb0f0f1          UDIV     r0,r0,r1
0008ea  9005              STR      r0,[sp,#0x14]
;;;478    			REG_POWERV = var32a;
0008ec  9805              LDR      r0,[sp,#0x14]
0008ee  e00d              B        |L3.2316|
                  |L3.2288|
                          DCD      UART_Buffer_Rece
                  |L3.2292|
                          DCD      Rmon_value
                  |L3.2296|
                          DCD      flagG
                  |L3.2300|
                          DCD      Imon_value
                  |L3.2304|
                          DCD      Contr_Current
                  |L3.2308|
                          DCD      Vmon_value
                  |L3.2312|
                          DCD      Contr_Voltage
                  |L3.2316|
00090c  f8c80020          STR      r0,[r8,#0x20]  ; Correct_Parametet
;;;479    			var32a = Modify_B_ACT;
000910  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000912  9005              STR      r0,[sp,#0x14]
;;;480    			var32a = var32a << 14;
000914  9805              LDR      r0,[sp,#0x14]
000916  0380              LSLS     r0,r0,#14
000918  9005              STR      r0,[sp,#0x14]
;;;481    			var32b = Modify_B_READ;
00091a  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
00091c  9004              STR      r0,[sp,#0x10]
;;;482    			var32b = var32b * REG_POWERV;
00091e  f8d80020          LDR      r0,[r8,#0x20]  ; Correct_Parametet
000922  9904              LDR      r1,[sp,#0x10]
000924  4348              MULS     r0,r1,r0
000926  9004              STR      r0,[sp,#0x10]
;;;483    			if (var32a < var32b)
000928  e9dd1004          LDRD     r1,r0,[sp,#0x10]
00092c  4288              CMP      r0,r1
00092e  d20a              BCS      |L3.2374|
;;;484    			{
;;;485    				var32b = var32b - var32a;
000930  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000934  1a40              SUBS     r0,r0,r1
000936  9004              STR      r0,[sp,#0x10]
;;;486    				REG_POWERV_Offset = var32b;
000938  9804              LDR      r0,[sp,#0x10]
00093a  6228              STR      r0,[r5,#0x20]  ; Correct_Strong
;;;487    				Polar5 |= 0x01;
00093c  7960              LDRB     r0,[r4,#5]  ; correct_por
00093e  f0400001          ORR      r0,r0,#1
000942  7160              STRB     r0,[r4,#5]
000944  e009              B        |L3.2394|
                  |L3.2374|
;;;488    			}
;;;489    			else 
;;;490    			{
;;;491    				var32a = var32a - var32b;
000946  e9dd1004          LDRD     r1,r0,[sp,#0x10]
00094a  1a40              SUBS     r0,r0,r1
00094c  9005              STR      r0,[sp,#0x14]
;;;492    				REG_POWERV_Offset = var32a;
00094e  9805              LDR      r0,[sp,#0x14]
000950  6228              STR      r0,[r5,#0x20]  ; Correct_Strong
;;;493    				Polar5 &= ~0x01;					
000952  7960              LDRB     r0,[r4,#5]  ; correct_por
000954  f0200001          BIC      r0,r0,#1
000958  7160              STRB     r0,[r4,#5]
                  |L3.2394|
;;;494    			}
;;;495    	//---------------------------------------------------------------------------------//
;;;496    			var32c = Modify_B_ACT; //设置电压校准
00095a  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
00095c  9002              STR      r0,[sp,#8]
;;;497    			var32c = var32c - Modify_A_ACT;
00095e  9802              LDR      r0,[sp,#8]
000960  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
000962  1a40              SUBS     r0,r0,r1
000964  9002              STR      r0,[sp,#8]
;;;498    			var32c = var32c << 14;
000966  9802              LDR      r0,[sp,#8]
000968  0380              LSLS     r0,r0,#14
00096a  9002              STR      r0,[sp,#8]
;;;499    			var16a=Modify_D_READ-Modify_C_READ;
00096c  6970              LDR      r0,[r6,#0x14]  ; Modify_D_READ
00096e  68b1              LDR      r1,[r6,#8]  ; Modify_C_READ
000970  1a40              SUBS     r0,r0,r1
000972  9003              STR      r0,[sp,#0xc]
;;;500    			var16a=var16a*2;
000974  f8bd100c          LDRH     r1,[sp,#0xc]
000978  f64f70ff          MOV      r0,#0xffff
00097c  ea000041          AND      r0,r0,r1,LSL #1
000980  9003              STR      r0,[sp,#0xc]
;;;501    			var32c=var32c/var16a;
000982  f8bd100c          LDRH     r1,[sp,#0xc]
000986  9802              LDR      r0,[sp,#8]
000988  fbb0f0f1          UDIV     r0,r0,r1
00098c  9002              STR      r0,[sp,#8]
;;;502    			SET_POWERV = var32c;
00098e  9802              LDR      r0,[sp,#8]
000990  f8c80024          STR      r0,[r8,#0x24]  ; Correct_Parametet
;;;503    			var32c = Modify_B_ACT;
000994  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000996  9002              STR      r0,[sp,#8]
;;;504    			var32c = var32c << 14;
000998  9802              LDR      r0,[sp,#8]
00099a  0380              LSLS     r0,r0,#14
00099c  9002              STR      r0,[sp,#8]
;;;505    			var32d = SET_POWERV;
00099e  f8d80024          LDR      r0,[r8,#0x24]  ; Correct_Parametet
0009a2  9001              STR      r0,[sp,#4]
;;;506    			var32d = var32d * (Modify_D_READ*2);
0009a4  9801              LDR      r0,[sp,#4]
0009a6  6971              LDR      r1,[r6,#0x14]  ; Modify_D_READ
0009a8  4348              MULS     r0,r1,r0
0009aa  e000              B        |L3.2478|
                  |L3.2476|
0009ac  e020              B        |L3.2544|
                  |L3.2478|
0009ae  0040              LSLS     r0,r0,#1
0009b0  9001              STR      r0,[sp,#4]
;;;507    			if (var32c < var32d)
0009b2  e9dd1001          LDRD     r1,r0,[sp,#4]
0009b6  4288              CMP      r0,r1
0009b8  d20a              BCS      |L3.2512|
;;;508    			{
;;;509    				var32d = var32d - var32c;
0009ba  e9dd0101          LDRD     r0,r1,[sp,#4]
0009be  1a40              SUBS     r0,r0,r1
0009c0  9001              STR      r0,[sp,#4]
;;;510    				SET_POWERV_Offset = var32d;
0009c2  9801              LDR      r0,[sp,#4]
0009c4  6268              STR      r0,[r5,#0x24]  ; Correct_Strong
;;;511    				Polar5 |= 0x04;
0009c6  7960              LDRB     r0,[r4,#5]  ; correct_por
0009c8  f0400004          ORR      r0,r0,#4
0009cc  7160              STRB     r0,[r4,#5]
0009ce  e009              B        |L3.2532|
                  |L3.2512|
;;;512    			}
;;;513    			else 
;;;514    			{
;;;515    				var32c = var32c - var32d;
0009d0  e9dd0101          LDRD     r0,r1,[sp,#4]
0009d4  1a08              SUBS     r0,r1,r0
0009d6  9002              STR      r0,[sp,#8]
;;;516    				SET_POWERV_Offset = var32c;
0009d8  9802              LDR      r0,[sp,#8]
0009da  6268              STR      r0,[r5,#0x24]  ; Correct_Strong
;;;517    				Polar5 &= ~0x04;
0009dc  7960              LDRB     r0,[r4,#5]  ; correct_por
0009de  f0200004          BIC      r0,r0,#4
0009e2  7160              STRB     r0,[r4,#5]
                  |L3.2532|
;;;518    			}
;;;519    			Flash_Write_all ();	
0009e4  f7fffffe          BL       Flash_Write_all
;;;520    			Flag_DAC_OFF=0;
0009e8  6838              LDR      r0,[r7,#0]  ; flagB
0009ea  f0200008          BIC      r0,r0,#8
0009ee  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2544|
;;;521    		}
;;;522    /****************电源电流测量校准**********************************/
;;;523    		if (UART_Buffer_Rece[1] == 0x0D)			  
0009f0  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
0009f4  280d              CMP      r0,#0xd
0009f6  d109              BNE      |L3.2572|
;;;524    		{ 
;;;525    			Modify_A_READ = Imon_value;
0009f8  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
0009fc  6070              STR      r0,[r6,#4]  ; Modify_A_READ
;;;526    			Modify_A_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
0009fe  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000a02  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000a06  eb002001          ADD      r0,r0,r1,LSL #8
000a0a  60f0              STR      r0,[r6,#0xc]  ; Modify_A_ACT
                  |L3.2572|
;;;527    		}
;;;528    
;;;529    		if (UART_Buffer_Rece[1] == 0x0E)			   
000a0c  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000a10  280e              CMP      r0,#0xe
000a12  d14a              BNE      |L3.2730|
;;;530    		{
;;;531    			vu16 var16;
;;;532    			vu32 var32a;
;;;533    			vu32 var32b;
;;;534    			
;;;535    			vu16 var16a;
;;;536    			vu32 var32c;
;;;537    			vu32 var32d;
;;;538    			
;;;539    			Modify_B_READ = Imon_value;
000a14  f8bb0000          LDRH     r0,[r11,#0]  ; Imon_value
000a18  6130              STR      r0,[r6,#0x10]  ; Modify_B_READ
;;;540    			Modify_B_ACT = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000a1a  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000a1e  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000a22  eb002001          ADD      r0,r0,r1,LSL #8
000a26  61b0              STR      r0,[r6,#0x18]  ; Modify_B_ACT
;;;541    			var32a = Modify_B_ACT;
000a28  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000a2a  9005              STR      r0,[sp,#0x14]
;;;542    			var32a = var32a - Modify_A_ACT;
000a2c  9805              LDR      r0,[sp,#0x14]
000a2e  68f1              LDR      r1,[r6,#0xc]  ; Modify_A_ACT
000a30  1a40              SUBS     r0,r0,r1
000a32  9005              STR      r0,[sp,#0x14]
;;;543    			var32a = var32a << 14;
000a34  9805              LDR      r0,[sp,#0x14]
000a36  0380              LSLS     r0,r0,#14
000a38  9005              STR      r0,[sp,#0x14]
;;;544    			var16 = Modify_B_READ - Modify_A_READ;
000a3a  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000a3c  6871              LDR      r1,[r6,#4]  ; Modify_A_READ
000a3e  1a40              SUBS     r0,r0,r1
000a40  9006              STR      r0,[sp,#0x18]
;;;545    			var32a = var32a / var16;
000a42  f8bd0018          LDRH     r0,[sp,#0x18]
000a46  9905              LDR      r1,[sp,#0x14]
000a48  fbb1f0f0          UDIV     r0,r1,r0
000a4c  9005              STR      r0,[sp,#0x14]
;;;546    			CON_POWERA = var32a;
000a4e  9805              LDR      r0,[sp,#0x14]
000a50  f8c80028          STR      r0,[r8,#0x28]  ; Correct_Parametet
;;;547    			var32a = Modify_B_ACT;
000a54  69b0              LDR      r0,[r6,#0x18]  ; Modify_B_ACT
000a56  9005              STR      r0,[sp,#0x14]
;;;548    			var32a = var32a << 14;
000a58  9805              LDR      r0,[sp,#0x14]
000a5a  0380              LSLS     r0,r0,#14
000a5c  9005              STR      r0,[sp,#0x14]
;;;549    			var32b = Modify_B_READ;
000a5e  6930              LDR      r0,[r6,#0x10]  ; Modify_B_READ
000a60  9004              STR      r0,[sp,#0x10]
;;;550    			var32b = var32b * CON_POWERA;
000a62  f8d80028          LDR      r0,[r8,#0x28]  ; Correct_Parametet
000a66  9904              LDR      r1,[sp,#0x10]
000a68  4348              MULS     r0,r1,r0
000a6a  9004              STR      r0,[sp,#0x10]
;;;551    			if (var32a < var32b)
000a6c  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000a70  4288              CMP      r0,r1
000a72  d20a              BCS      |L3.2698|
;;;552    			{
;;;553    				var32b = var32b - var32a;
000a74  e9dd0104          LDRD     r0,r1,[sp,#0x10]
000a78  1a40              SUBS     r0,r0,r1
000a7a  9004              STR      r0,[sp,#0x10]
;;;554    				CON_POWERA_Offset = var32b;
000a7c  9804              LDR      r0,[sp,#0x10]
000a7e  62a8              STR      r0,[r5,#0x28]  ; Correct_Strong
;;;555    				Polar3 |= 0x04;
000a80  78e0              LDRB     r0,[r4,#3]  ; correct_por
000a82  f0400004          ORR      r0,r0,#4
000a86  70e0              STRB     r0,[r4,#3]
000a88  e009              B        |L3.2718|
                  |L3.2698|
;;;556    			}
;;;557    			else 
;;;558    			{
;;;559    				var32a = var32a - var32b;
000a8a  e9dd1004          LDRD     r1,r0,[sp,#0x10]
000a8e  1a40              SUBS     r0,r0,r1
000a90  9005              STR      r0,[sp,#0x14]
;;;560    				CON_POWERA_Offset = var32a;
000a92  9805              LDR      r0,[sp,#0x14]
000a94  62a8              STR      r0,[r5,#0x28]  ; Correct_Strong
;;;561    				Polar3 &= ~0x04;					
000a96  78e0              LDRB     r0,[r4,#3]  ; correct_por
000a98  f0200004          BIC      r0,r0,#4
000a9c  70e0              STRB     r0,[r4,#3]
                  |L3.2718|
;;;562    			}
;;;563    			Flash_Write_all ();	
000a9e  f7fffffe          BL       Flash_Write_all
;;;564    			Flag_DAC_OFF=0;
000aa2  6838              LDR      r0,[r7,#0]  ; flagB
000aa4  f0200008          BIC      r0,r0,#8
000aa8  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2730|
;;;565    		}
;;;566    /***********接受DAC*******************************************/
;;;567    		if (UART_Buffer_Rece[1] == 0x0F)			   
000aaa  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000aae  280f              CMP      r0,#0xf
000ab0  d10b              BNE      |L3.2762|
;;;568    		{
;;;569    			Contr_Laod = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000ab2  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000ab6  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000aba  eb002001          ADD      r0,r0,r1,LSL #8
000abe  f8aa0000          STRH     r0,[r10,#0]
;;;570    			Flag_DAC_OFF=1;
000ac2  6838              LDR      r0,[r7,#0]  ; flagB
000ac4  f0400008          ORR      r0,r0,#8
000ac8  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2762|
;;;571    		}
;;;572    		if (UART_Buffer_Rece[1] == 0x20)			   
000aca  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000ace  2820              CMP      r0,#0x20
000ad0  d10b              BNE      |L3.2794|
;;;573    		{
;;;574    			Contr_Voltage = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000ad2  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000ad6  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000ada  eb002001          ADD      r0,r0,r1,LSL #8
000ade  490c              LDR      r1,|L3.2832|
000ae0  8008              STRH     r0,[r1,#0]
;;;575    			Flag_DAC_OFF=1;
000ae2  6838              LDR      r0,[r7,#0]  ; flagB
000ae4  f0400008          ORR      r0,r0,#8
000ae8  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2794|
;;;576    		}
;;;577    		if (UART_Buffer_Rece[1] == 0x21)			   
000aea  f8990001          LDRB     r0,[r9,#1]  ; UART_Buffer_Rece
000aee  2821              CMP      r0,#0x21
000af0  d10b              BNE      |L3.2826|
;;;578    		{
;;;579    			Contr_Current = (UART_Buffer_Rece[3] << 8) + UART_Buffer_Rece[4];
000af2  f8990004          LDRB     r0,[r9,#4]  ; UART_Buffer_Rece
000af6  f8991003          LDRB     r1,[r9,#3]  ; UART_Buffer_Rece
000afa  eb002001          ADD      r0,r0,r1,LSL #8
000afe  4905              LDR      r1,|L3.2836|
000b00  8008              STRH     r0,[r1,#0]
;;;580    			Flag_DAC_OFF=1;
000b02  6838              LDR      r0,[r7,#0]  ; flagB
000b04  f0400008          ORR      r0,r0,#8
000b08  6038              STR      r0,[r7,#0]  ; flagB
                  |L3.2826|
;;;581    		}
;;;582    	}
;;;583    //===================================================================================
;;;584    }
000b0a  b007              ADD      sp,sp,#0x1c
000b0c  e8bd8ff0          POP      {r4-r11,pc}
;;;585    //===============================AD值转换成测量值============================================//
                          ENDP

                  |L3.2832|
                          DCD      Contr_Voltage
                  |L3.2836|
                          DCD      Contr_Current

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Correct_Parametet
                          %        44
                  Correct_Strong
                          %        44
                  Run_Control
                          %        56

                          AREA ||.data||, DATA, ALIGN=1

                  ADJ_Write
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  DAC_Flag
000000  00                DCB      0x00
                  ADDR
000001  000000            DCB      0x00,0x00,0x00
                  Modify_A_READ
                          DCD      0x00000000
                  Modify_C_READ
                          DCD      0x00000000
                  Modify_A_ACT
                          DCD      0x00000000
                  Modify_B_READ
                          DCD      0x00000000
                  Modify_D_READ
                          DCD      0x00000000
                  Modify_B_ACT
                          DCD      0x00000000
                  correct_por
                          DCD      0x00000000
000020  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\modbus.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REV16|
#line 129 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_modbus_c_bae18981____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_modbus_c_bae18981____REVSH|
#line 144
|__asm___8_modbus_c_bae18981____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
