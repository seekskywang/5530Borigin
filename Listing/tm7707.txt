; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\Output\tm7707.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\Output\tm7707.d --cpu=Cortex-M4.fp --apcs=interwork -O1 --diag_suppress=870 -I..\APP -I..\drive -I..\Include -I..\Libraries\CMSIS\inc -I..\Libraries\CMSIS\src -I..\Libraries\FWlib\inc -I..\Libraries\FWlib\src -I..\Listing -I..\Output -I..\Project -I..\STemWinLibrary522\Config -I..\STemWinLibrary522\emWinTask -I..\STemWinLibrary522\GUILib -I..\STemWinLibrary522\inc -I..\User -I..\USB\STM32_USB_HOST_Library\Class\HID\inc -I..\USB\STM32_USB_HOST_Library\Class\MSC\src -I..\USB\STM32_USB_HOST_Library\Core\src -I..\USB\USB_APP -I..\USB\STM32_USB_HOST_Library\Class\HID\src -I..\USB\STM32_USB_HOST_Library\Class\MSC\inc -I..\USB\STM32_USB_HOST_Library\Core\inc -I..\USB\STM32_USB_OTG_Driver\inc -I..\FATFS\exfuns -I..\FATFS\src\option -I..\FATFS\src -I..\MALLOC -ID:\Keil\ARM\RV31\Inc -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F4xx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_FS -DUSE_EMBEDDED_PHY -DUSE_USB_OTG_HS -DSTM32F40XX --omf_browse=..\Output\tm7707.crf ..\drive\TM7707.c]
                          THUMB

                          AREA ||i.TM7707_Delay||, CODE, READONLY, ALIGN=1

                  TM7707_Delay PROC
;;;48     //Simple delay function
;;;49     void TM7707_Delay(vu16 nCount)
000000  2100              MOVS     r1,#0
;;;50     {
;;;51     	vu16	i;
;;;52     	for(i=0; i<nCount; i++)
000002  e002              B        |L1.10|
                  |L1.4|
;;;53     	{
;;;54     		NOP;
000004  bf00              NOP      
000006  1c49              ADDS     r1,r1,#1              ;52
000008  b289              UXTH     r1,r1                 ;52
                  |L1.10|
00000a  4281              CMP      r1,r0                 ;52
00000c  d3fa              BCC      |L1.4|
;;;55     	}
;;;56     }
00000e  4770              BX       lr
;;;57     
                          ENDP


                          AREA ||i.TM7707_Initialize||, CODE, READONLY, ALIGN=1

                  TM7707_Initialize PROC
;;;227    /************************************************************************/
;;;228    void TM7707_Initialize(void)
000000  b510              PUSH     {r4,lr}
;;;229    {
;;;230    	// Initialize SPI controler.
;;;231    	TM7707_InitializeSPI2();
000002  f7fffffe          BL       TM7707_InitializeSPI2
;;;232    	TM7707_Reset();
000006  f7fffffe          BL       TM7707_Reset
;;;233    	// Synchronize device clock.
;;;234    	TM7707_SynchronizeDeviceClock();
00000a  f7fffffe          BL       TM7707_SynchronizeDeviceClock
;;;235    	TM7707_SelfCalibration(CH_1, GAIN_1);
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       TM7707_SelfCalibration
;;;236      TM7707_SelfCalibration(CH_2, GAIN_1);
000016  2100              MOVS     r1,#0
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       TM7707_SelfCalibration
;;;237    	// Configure the clock registers
;;;238    	TM7707_TransferByte(REG_CLOCK | WRITE | CH_1); // Write communication register to set clook register.
00001e  2020              MOVS     r0,#0x20
000020  f7fffffe          BL       TM7707_TransferByte
;;;239    	TM7707_TransferByte(CLKDIS_0 | CLK_4_9152M | FS_50HZ); // External clock, frequency is 4.9152 MHz and the sampling frequency is 500Hz.
000024  2008              MOVS     r0,#8
000026  f7fffffe          BL       TM7707_TransferByte
;;;240    	TM7707_TransferByte(REG_CLOCK | WRITE | CH_2); // Write communication register to set clook register.
00002a  2021              MOVS     r0,#0x21
00002c  f7fffffe          BL       TM7707_TransferByte
;;;241    	TM7707_TransferByte(CLKDIS_0 | CLK_4_9152M | FS_50HZ); // External clock, frequency is 4.9152 MHz and the sampling frequency is 500Hz.
000030  e8bd4010          POP      {r4,lr}
000034  2008              MOVS     r0,#8
000036  f7ffbffe          B.W      TM7707_TransferByte
;;;242    }
;;;243    void TM7707_Reset(void)
                          ENDP


                          AREA ||i.TM7707_InitializeSPI2||, CODE, READONLY, ALIGN=2

                  TM7707_InitializeSPI2 PROC
;;;58     
;;;59     void TM7707_InitializeSPI2(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;60     {
000004  b088              SUB      sp,sp,#0x20
;;;61     	GPIO_InitTypeDef  GPIO_InitStructure;
;;;62       SPI_InitTypeDef  SPI_InitStructure;
;;;63     	TM7707_CS_DISABLE();	;//CS1
000006  f8df8098          LDR      r8,|L3.160|
00000a  2140              MOVS     r1,#0x40
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       GPIO_SetBits
;;;64       /*!< SD_SPI_CS_GPIO, SD_SPI_MOSI_GPIO, SD_SPI_MISO_GPIO, SD_SPI_DETECT_GPIO 
;;;65            and SD_SPI_SCK_GPIO Periph clock enable 
;;;66     	// 	 RCC_AHBPeriphClockCmd(FLASH_CS_PIN_SCK|FLASH_SCK_PIN_SCK|FLASH_MISO_PIN_SCK | FLASH_MOSI_PIN_SCK, ENABLE);
;;;67       !< SD_SPI Periph clock enable */
;;;68     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);
000012  2101              MOVS     r1,#1
000014  03c8              LSLS     r0,r1,#15
000016  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;69       /*!< Configure SD_SPI pins: SPI1 */
;;;70       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;//PB3~5复用功能输出	
00001a  2738              MOVS     r7,#0x38
00001c  9706              STR      r7,[sp,#0x18]
;;;71       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;//复用功能
00001e  2502              MOVS     r5,#2
000020  f88d501c          STRB     r5,[sp,#0x1c]
;;;72       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;//推挽输出
000024  2400              MOVS     r4,#0
000026  f88d401e          STRB     r4,[sp,#0x1e]
;;;73       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
00002a  2003              MOVS     r0,#3
00002c  f88d001d          STRB     r0,[sp,#0x1d]
;;;74       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
000030  2601              MOVS     r6,#1
000032  f88d601f          STRB     r6,[sp,#0x1f]
;;;75       GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化
000036  a906              ADD      r1,sp,#0x18
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       GPIO_Init
;;;76     	
;;;77       GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI3); //PB3复用为 SPI1
00003e  2206              MOVS     r2,#6
000040  2103              MOVS     r1,#3
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       GPIO_PinAFConfig
;;;78     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI3); //PB4复用为 SPI1
000048  2206              MOVS     r2,#6
00004a  2104              MOVS     r1,#4
00004c  4640              MOV      r0,r8
00004e  f7fffffe          BL       GPIO_PinAFConfig
;;;79     	GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI3); //PB5复用为 SPI1
000052  2206              MOVS     r2,#6
000054  2105              MOVS     r1,#5
000056  4640              MOV      r0,r8
000058  f7fffffe          BL       GPIO_PinAFConfig
;;;80     
;;;81     	//这里只针对SPI口初始化
;;;82       SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;  //设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工
00005c  f8ad4004          STRH     r4,[sp,#4]
;;;83     	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		//设置SPI工作模式:设置为主SPI
000060  f44f7082          MOV      r0,#0x104
000064  f8ad0006          STRH     r0,[sp,#6]
;;;84     	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;		//设置SPI的数据大小:SPI发送接收8位帧结构
000068  f8ad4008          STRH     r4,[sp,#8]
;;;85     	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;		//串行同步时钟的空闲状态为高电平
00006c  f8ad500a          STRH     r5,[sp,#0xa]
;;;86     	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;	//串行同步时钟的第二个跳变沿（上升或下降）数据被采样
000070  f8ad600c          STRH     r6,[sp,#0xc]
;;;87     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;		//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制
000074  0228              LSLS     r0,r5,#8
000076  f8ad000e          STRH     r0,[sp,#0xe]
;;;88     	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;		//定义波特率预分频的值:波特率预分频值为256
00007a  f8ad7010          STRH     r7,[sp,#0x10]
;;;89     	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始
00007e  f8ad4012          STRH     r4,[sp,#0x12]
;;;90     	SPI_InitStructure.SPI_CRCPolynomial = 7;	//CRC值计算的多项式
000082  2007              MOVS     r0,#7
000084  f8ad0014          STRH     r0,[sp,#0x14]
;;;91     	SPI_Init(SPI3, &SPI_InitStructure);  //根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器
000088  4c06              LDR      r4,|L3.164|
00008a  a901              ADD      r1,sp,#4
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       SPI_Init
;;;92     	
;;;93     	SPI_Cmd(SPI3, ENABLE); //使能SPI外设*/
000092  2101              MOVS     r1,#1
000094  4620              MOV      r0,r4
000096  f7fffffe          BL       SPI_Cmd
;;;94     		 
;;;95     }
00009a  b008              ADD      sp,sp,#0x20
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;96     vu32 TM7707_ReadADCValue(vu8 uiChannelIndex)
                          ENDP

                  |L3.160|
                          DCD      0x40020400
                  |L3.164|
                          DCD      0x40003c00

                          AREA ||i.TM7707_ReadADCValue||, CODE, READONLY, ALIGN=2

                  TM7707_ReadADCValue PROC
;;;95     }
;;;96     vu32 TM7707_ReadADCValue(vu8 uiChannelIndex)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;97     {
;;;98     	vu16 i;
;;;99     	vu32 rtnADValue = 0;
000004  2400              MOVS     r4,#0
;;;100    
;;;101    	// Write channel index.
;;;102    	// Wait for the conversion to complete
;;;103    	if(uiChannelIndex==CH_1)//读第一通道
;;;104    	{
;;;105    		
;;;106    		for(i=0; i<100; i++)
;;;107    		{
;;;108    			while(TM7707_ReadPin() == 0)
000006  f8dfa0ac          LDR      r10,|L4.180|
;;;109    			{
;;;110    				TM7707_TransferByte(0x38);
;;;111    				rtnADValue|= TM7707_TransferByte(0xFF);
;;;112    				rtnADValue <<= 8;
;;;113    				rtnADValue|= TM7707_TransferByte(0xFF);
;;;114    				rtnADValue <<= 8;
;;;115    				rtnADValue|= TM7707_TransferByte(0xFF);
;;;116    				Imon1_value=rtnADValue>>6;//负载电流
;;;117    				flag_TM7707_CH =0;
00000a  4f2b              LDR      r7,|L4.184|
00000c  f44f7980          MOV      r9,#0x100             ;108
000010  b118              CBZ      r0,|L4.26|
;;;118    			}
;;;119    		}
;;;120    	}
;;;121    	else if(uiChannelIndex==CH_2)//读第二通道
000012  2801              CMP      r0,#1
000014  d129              BNE      |L4.106|
;;;122    	{
;;;123    		for(i=0; i<100; i++)
000016  2500              MOVS     r5,#0
000018  e049              B        |L4.174|
                  |L4.26|
00001a  2500              MOVS     r5,#0                 ;106
00001c  e023              B        |L4.102|
                  |L4.30|
00001e  f8df809c          LDR      r8,|L4.188|
000022  e018              B        |L4.86|
                  |L4.36|
000024  2038              MOVS     r0,#0x38              ;110
000026  f7fffffe          BL       TM7707_TransferByte
00002a  20ff              MOVS     r0,#0xff              ;111
00002c  f7fffffe          BL       TM7707_TransferByte
000030  4320              ORRS     r0,r0,r4              ;111
000032  0204              LSLS     r4,r0,#8              ;112
000034  20ff              MOVS     r0,#0xff              ;113
000036  f7fffffe          BL       TM7707_TransferByte
00003a  4320              ORRS     r0,r0,r4              ;113
00003c  0206              LSLS     r6,r0,#8              ;114
00003e  20ff              MOVS     r0,#0xff              ;115
000040  f7fffffe          BL       TM7707_TransferByte
000044  ea400406          ORR      r4,r0,r6              ;115
000048  09a0              LSRS     r0,r4,#6              ;116
00004a  f8c80000          STR      r0,[r8,#0]            ;116  ; Imon1_value
00004e  6838              LDR      r0,[r7,#0]            ;117  ; flagG
000050  f0200080          BIC      r0,r0,#0x80           ;117
000054  6038              STR      r0,[r7,#0]            ;117  ; flagG
                  |L4.86|
000056  4649              MOV      r1,r9                 ;108
000058  4650              MOV      r0,r10                ;108
00005a  f7fffffe          BL       GPIO_ReadInputDataBit
00005e  2800              CMP      r0,#0                 ;108
000060  d0e0              BEQ      |L4.36|
000062  1c6d              ADDS     r5,r5,#1              ;106
000064  b2ad              UXTH     r5,r5                 ;106
                  |L4.102|
000066  2d64              CMP      r5,#0x64              ;106
000068  d3d9              BCC      |L4.30|
                  |L4.106|
;;;124    		{
;;;125    			if(TM7707_ReadPin() == 0)
;;;126    			{
;;;127    				TM7707_TransferByte(0x39);
;;;128    				rtnADValue |= TM7707_TransferByte(0xFF);
;;;129    				rtnADValue <<= 8;
;;;130    				rtnADValue |= TM7707_TransferByte(0xFF);
;;;131    				rtnADValue <<= 8;
;;;132    				rtnADValue |= TM7707_TransferByte(0xFF);
;;;133    				Vmon1_value=rtnADValue>>6;//负载电压
;;;134    				flag_TM7707_CH =1;
;;;135    			}
;;;136    		}
;;;137    	}
;;;138    }
00006a  e8bd87f0          POP      {r4-r10,pc}
                  |L4.110|
00006e  4649              MOV      r1,r9                 ;125
000070  4650              MOV      r0,r10                ;125
000072  f7fffffe          BL       GPIO_ReadInputDataBit
000076  b9c0              CBNZ     r0,|L4.170|
000078  2039              MOVS     r0,#0x39              ;127
00007a  f7fffffe          BL       TM7707_TransferByte
00007e  20ff              MOVS     r0,#0xff              ;128
000080  f7fffffe          BL       TM7707_TransferByte
000084  4320              ORRS     r0,r0,r4              ;128
000086  0204              LSLS     r4,r0,#8              ;129
000088  20ff              MOVS     r0,#0xff              ;130
00008a  f7fffffe          BL       TM7707_TransferByte
00008e  4320              ORRS     r0,r0,r4              ;130
000090  0206              LSLS     r6,r0,#8              ;131
000092  20ff              MOVS     r0,#0xff              ;132
000094  f7fffffe          BL       TM7707_TransferByte
000098  ea400406          ORR      r4,r0,r6              ;132
00009c  4908              LDR      r1,|L4.192|
00009e  09a0              LSRS     r0,r4,#6              ;133
0000a0  6008              STR      r0,[r1,#0]            ;133  ; Vmon1_value
0000a2  6838              LDR      r0,[r7,#0]            ;134  ; flagG
0000a4  f0400080          ORR      r0,r0,#0x80           ;134
0000a8  6038              STR      r0,[r7,#0]            ;134  ; flagG
                  |L4.170|
0000aa  1c6d              ADDS     r5,r5,#1              ;123
0000ac  b2ad              UXTH     r5,r5                 ;123
                  |L4.174|
0000ae  2d64              CMP      r5,#0x64              ;123
0000b0  d3dd              BCC      |L4.110|
0000b2  e7da              B        |L4.106|
;;;139    
                          ENDP

                  |L4.180|
                          DCD      0x40020400
                  |L4.184|
                          DCD      flagG
                  |L4.188|
                          DCD      Imon1_value
                  |L4.192|
                          DCD      Vmon1_value

                          AREA ||i.TM7707_Reset||, CODE, READONLY, ALIGN=2

                  TM7707_Reset PROC
;;;242    }
;;;243    void TM7707_Reset(void)
000000  b570              PUSH     {r4-r6,lr}
;;;244    {
;;;245    		TM7707_ST_RESET();
000002  4c09              LDR      r4,|L5.40|
000004  2180              MOVS     r1,#0x80
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;246    		TM7707_Delay(5000);
00000c  f2413588          MOV      r5,#0x1388
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       TM7707_Delay
;;;247    		TM7707_ST_UNRESET();
000016  2180              MOVS     r1,#0x80
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       GPIO_SetBits
;;;248    		TM7707_Delay(5000);
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  f7ffbffe          B.W      TM7707_Delay
;;;249    }
                          ENDP

                  |L5.40|
                          DCD      0x40020400

                          AREA ||i.TM7707_SelfCalibration||, CODE, READONLY, ALIGN=1

                  TM7707_SelfCalibration PROC
;;;208    /************************************************************************/
;;;209    void TM7707_SelfCalibration(vu8	uiChannelIndex, vu8 uiGain)
000000  b510              PUSH     {r4,lr}
;;;210    {
000002  460c              MOV      r4,r1
;;;211    	uiChannelIndex = uiChannelIndex % CH_MAX;
000004  f0000003          AND      r0,r0,#3
;;;212    	//Write communication register to set setup register.
;;;213    	TM7707_TransferByte(REG_SETUP | WRITE | uiChannelIndex);
000008  f0400010          ORR      r0,r0,#0x10
00000c  f7fffffe          BL       TM7707_TransferByte
;;;214    	//Write configuration register, start self-calibration.
;;;215    	TM7707_TransferByte(MD_NORMAL | uiGain | UNIPOLAR | BUF_NO | FSYNC_0);
000010  f0440004          ORR      r0,r4,#4
000014  f7fffffe          BL       TM7707_TransferByte
;;;216    	// Wait for operation to complete(ablut 180ms).
;;;217    	TM7707_WaitForDRDY();
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      TM7707_WaitForDRDY
;;;218    }
;;;219    
                          ENDP


                          AREA ||i.TM7707_SynchronizeDeviceClock||, CODE, READONLY, ALIGN=1

                  TM7707_SynchronizeDeviceClock PROC
;;;169    /************************************************************************/
;;;170    void TM7707_SynchronizeDeviceClock(void)
000000  b510              PUSH     {r4,lr}
;;;171    {
;;;172    	vu8 i;
;;;173    	// Keep SCLK pin high at 40 cycles.
;;;174    	for(i=0; i<5; i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L7.16|
                  |L7.6|
;;;175    	{
;;;176    		TM7707_TransferByte(0xFF);
000006  20ff              MOVS     r0,#0xff
000008  f7fffffe          BL       TM7707_TransferByte
00000c  1c64              ADDS     r4,r4,#1              ;174
00000e  b2e4              UXTB     r4,r4                 ;174
                  |L7.16|
000010  2c05              CMP      r4,#5                 ;174
000012  d3f8              BCC      |L7.6|
;;;177    	}
;;;178    }
000014  bd10              POP      {r4,pc}
;;;179    
                          ENDP


                          AREA ||i.TM7707_TransferByte||, CODE, READONLY, ALIGN=2

                  TM7707_TransferByte PROC
;;;148    /************************************************************************/
;;;149    vu8 TM7707_TransferByte(vu8 uiTxData)
000000  b570              PUSH     {r4-r6,lr}
;;;150    {
000002  4604              MOV      r4,r0
;;;151    	vu8 uiRxData;
;;;152    	TM7707_CS_ENABLE();		// CS = 1;
000004  4e0f              LDR      r6,|L8.68|
000006  2140              MOVS     r1,#0x40
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       GPIO_ResetBits
;;;153    	while (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE) == RESET);
00000e  4d0e              LDR      r5,|L8.72|
                  |L8.16|
000010  2102              MOVS     r1,#2
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SPI_I2S_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L8.16|
;;;154    	SPI_I2S_SendData(SPI3,uiTxData);
00001c  4621              MOV      r1,r4
00001e  462c              MOV      r4,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SPI_I2S_SendData
                  |L8.38|
;;;155    	while (SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE) == RESET);
000026  2101              MOVS     r1,#1
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00002e  2800              CMP      r0,#0
000030  d0f9              BEQ      |L8.38|
;;;156    	TM7707_CS_DISABLE();	// CS = 0;
000032  2140              MOVS     r1,#0x40
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       GPIO_SetBits
;;;157    	uiRxData = SPI_I2S_ReceiveData(SPI3);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       SPI_I2S_ReceiveData
000040  b2c0              UXTB     r0,r0
;;;158    	return uiRxData;
;;;159    }
000042  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP

                  |L8.68|
                          DCD      0x40020400
                  |L8.72|
                          DCD      0x40003c00

                          AREA ||i.TM7707_WaitForDRDY||, CODE, READONLY, ALIGN=2

                  TM7707_WaitForDRDY PROC
;;;187    /************************************************************************/
;;;188    void TM7707_WaitForDRDY(void)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
;;;190    		/*vu16 i;
;;;191    	for(i=0; i<100; i++)
;;;192    	{
;;;193    		if(TM7707_ReadPin() == 0)
;;;194    			break;
;;;195    	}*/
;;;196    while(TM7707_ReadPin() != 0);
000002  4d05              LDR      r5,|L9.24|
000004  f44f7480          MOV      r4,#0x100
                  |L9.8|
000008  4621              MOV      r1,r4
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_ReadInputDataBit
000010  2800              CMP      r0,#0
000012  d1f9              BNE      |L9.8|
;;;197    
;;;198    }
000014  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40020400

                          AREA ||.data||, DATA, ALIGN=0

                  tm_adc_vol
000000  00                DCB      0x00

                          AREA ||area_number.13||, DATA, ALIGN=0

                          EXPORTAS ||area_number.13||, ||.data||
                  tm_adc_vol2
000000  00                DCB      0x00

                          AREA ||area_number.14||, DATA, ALIGN=0

                          EXPORTAS ||area_number.14||, ||.data||
                  tm_adc_vol3
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\drive\\TM7707.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_TM7707_c_39a3edaf____REV16|
#line 114 "D:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_TM7707_c_39a3edaf____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_TM7707_c_39a3edaf____REVSH|
#line 128
|__asm___8_TM7707_c_39a3edaf____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
